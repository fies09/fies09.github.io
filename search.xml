<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Controller接口设计</title>
    <url>/article/5e622f88.html</url>
    <content><![CDATA[<h2 id="1-签名"><a href="#1-签名" class="headerlink" title="1. 签名"></a>1. 签名</h2><p>为了防止Controller接口中的数据被篡改，很多时候我们需要对Controller接口做<code>签名</code>。</p>
<p>接口请求方将<code>请求参数</code> + <code>时间戳</code> + <code>密钥</code>拼接成一个字符串，然后通过<code>md5</code>等hash算法，生成一个前面sign。</p>
<p>然后在请求参数或者请求头中，增加sign参数，传递给API接口。</p>
<p>API接口的网关服务，获取到该sign值，然后用相同的请求参数 + 时间戳 + 密钥拼接成一个字符串，用相同的m5算法生成另外一个sign，对比两个sign值是否相等。</p>
<p>如果两个sign相等，则认为是有效请求，API接口的网关服务会将给请求转发给相应的业务系统。</p>
<p>如果两个sign不相等，则API接口的网关服务会直接返回签名错误。</p>
<p>问题来了：签名中为什么要加时间戳？</p>
<p>答：为了安全性考虑，防止同一次请求被反复利用，增加了密钥没破解的可能性，我们必须要对每次请求都设置一个合理的过期时间，比如：15分钟。</p>
<p>这样一次请求，在15分钟之内是有效的，超过15分钟，API接口的网关服务会返回超过有效期的异常提示。</p>
<p>目前生成签名中的密钥有两种形式：</p>
<p>一种是双方约定一个固定值privateKey。</p>
<p>另一种是API接口提供方给出AK&#x2F;SK两个值，双方约定用SK作为签名中的密钥。AK接口调用方作为header中的accessKey传递给API接口提供方，这样API接口提供方可以根据AK获取到SK，而生成新的sgin。</p>
<h2 id="2-加密"><a href="#2-加密" class="headerlink" title="2. 加密"></a>2. 加密</h2><p>有些时候，我们的Controller接口直接传递的非常重要的数据，比如：用户的登录密码、银行卡号、转账金额、用户身份证等，如果将这些参数，直接明文，暴露到公网上是非常危险的事情。</p>
<p>由此，我们需要对数据进行非对称加密。</p>
<p>目前使用比较多的是用<code>RSA</code>。</p>
<p>RSA包含了一对：<code>公钥</code>和<code>私钥</code>。</p>
<p>我们以用户登录密码为例。</p>
<p>在用户输入密码之后，在前端需要对密码使用公钥做加密处理。</p>
<p>公钥是保留在前端代码中的，即使泄露给别人了，也没关系。</p>
<p>因为使用公钥加密后的密码，只能使用后端服务中对应的私钥才能解密。</p>
<p>而我们私钥保存在后端服务的配置中，别人无法获取到。</p>
<p>因此，使用RSA加密和解密是安全的。</p>
<p>我们可以使用在线工具生成密钥对：<a href="https://tools.ytdevops.com/rsa-key-pair-generator">https://tools.ytdevops.com/rsa-key-pair-generator</a></p>
<h2 id="3-ip白名单"><a href="#3-ip白名单" class="headerlink" title="3. ip白名单"></a>3. ip白名单</h2><p>为了进一步加强API接口的安全性，防止接口的签名或者加密被破解了，攻击者可以在自己的服务器上请求该接口。</p>
<p>需求限制请求<code>ip</code>，增加<code>ip白名单</code>。</p>
<p>只有在白名单中的ip地址，才能成功请求API接口，否则直接返回无访问权限。</p>
<p>ip白名单也可以加在API网关服务上。</p>
<p>但也要防止公司的内部应用服务器被攻破，这种情况也可以从内部服务器上发起API接口的请求。</p>
<p>这时候就需要增加web防火墙了，比如：ModSecurity等。</p>
<h2 id="4-限流"><a href="#4-限流" class="headerlink" title="4. 限流"></a>4. 限流</h2><p>如果你的API接口被第三方平台调用了，这就意味着着，调用频率是没法控制的。</p>
<p>第三方平台调用你的API接口时，如果并发量一下子太高，可能会导致你的API服务不可用，接口直接挂掉。</p>
<p>由此，必须要对API接口做<code>限流</code>。</p>
<p>限流方法有三种：</p>
<ol>
<li>对请求ip做限流：比如同一个ip，在一分钟内，对<code>API接口总的请求次数</code>，不能超过10000次。</li>
<li>对请求接口做限流：比如同一个ip，在一分钟内，对<code>指定的API接口</code>，请求次数不能超过2000次。</li>
<li>对请求用户做限流：比如同一个<code>AK/SK用户</code>，在一分钟内，对API接口总的请求次数，不能超过10000次。</li>
</ol>
<p>我们在实际工作中，可以通过<code>nginx</code>，<code>redis</code>或者<code>gateway</code>实现限流的功能。</p>
<h2 id="5-参数校验"><a href="#5-参数校验" class="headerlink" title="5. 参数校验"></a>5. 参数校验</h2><p>我们需要对API接口做<code>参数校验</code>，比如：校验必填字段是否为空，校验字段类型，校验字段长度，校验枚举值等等。</p>
<p>这样做可以拦截一些无效的请求。</p>
<p>比如在新增数据时，字段长度超过了数据字段的最大长度，数据库会直接报错。</p>
<p>但这种异常的请求，我们完全可以在API接口的前期进行识别，没有必要走到数据库保存数据那一步，浪费系统资源。</p>
<p>有些金额字段，本来是正数，但如果用户传入了负数，万一接口没做校验，可能会导致一些没必要的损失。</p>
<p>还有些状态字段，如果不做校验，用户如果传入了系统中不存在的枚举值，就会导致保存的数据异常。</p>
<p>由此可见，做参数校验是非常有必要的。</p>
<p>在Java中校验数据使用最多的是<code>hiberate</code>的<code>Validator</code>框架，它里面包含了@Null、@NotEmpty、@Size、@Max、@Min等注解。</p>
<p>用它们校验数据非常方便。</p>
<p>当然有些日期字段和枚举字段，可能需要通过自定义注解的方式实现参数校验。</p>
<h2 id="6-统一返回值"><a href="#6-统一返回值" class="headerlink" title="6. 统一返回值"></a>6. 统一返回值</h2><p>我之前调用过别人的API接口，正常返回数据是一种json格式，比如：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:[&#123;<span class="string">&quot;id&quot;</span>:<span class="number">123</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>签名错误返回的json格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>:<span class="number">1001</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>:<span class="string">&quot;签名错误&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有数据权限返回的json格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;rt&quot;</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;errorMgt&quot;</span>:<span class="string">&quot;没有权限&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是比较坑的做法，返回值中有多种不同格式的返回数据，这样会导致对接方很难理解。</p>
<p>出现这种情况，可能是API网关定义了一直返回值结构，业务系统定义了另外一种返回值结构。如果是网关异常，则返回网关定义的返回值结构，如果是业务系统异常，则返回业务系统的返回值结构。</p>
<p>但这样会导致API接口出现不同的异常时，返回不同的返回值结构，非常不利于接口的维护。</p>
<p>其实这个问题我们可以在设计<code>API网关</code>时解决。</p>
<p>业务系统在出现异常时，抛出业务异常的RuntimeException，其中有个message字段定义异常信息。</p>
<p>所有的API接口都必须经过API网关，API网关捕获该业务异常，然后转换成统一的异常结构返回，这样能统一返回值结构。</p>
<h2 id="7-统一封装异常"><a href="#7-统一封装异常" class="headerlink" title="7. 统一封装异常"></a>7. 统一封装异常</h2><p>我们的API接口需要对<code>异常</code>进行统一处理。</p>
<p>不知道你有没有遇到过这种场景：有时候在API接口中，需要访问数据库，但表不存在，或者sql语句异常，就会直接把sql信息在API接口中直接返回。</p>
<p>返回值中包含了<code>异常堆栈信息</code>、<code>数据库信息</code>、<code>错误代码和行数</code>等信息。</p>
<p>如果直接把这些内容暴露给第三方平台，是很危险的事情。</p>
<p>有些不法分子，利用接口返回值中的这些信息，有可能会进行sql注入或者直接脱库，而对我们系统造成一定的损失。</p>
<p>因此非常有必要对API接口中的异常做统一处理，把异常转换成这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>:<span class="number">500</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>:<span class="string">&quot;服务器内部错误&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回码<code>code</code>是<code>500</code>，返回信息<code>message</code>是<code>服务器内部异常</code>。</p>
<p>这样第三方平台就知道是API接口出现了内部问题，但不知道具体原因，他们可以找我们排查问题。</p>
<p>我们可以在内部的日志文件中，把堆栈信息、数据库信息、错误代码行数等信息，打印出来。</p>
<p>我们可以在<code>gateway</code>中对异常进行拦截，做统一封装，然后给第三方平台的是处理后没有敏感信息的错误信息。</p>
<h2 id="8-请求日志"><a href="#8-请求日志" class="headerlink" title="8. 请求日志"></a>8. 请求日志</h2><p>在第三方平台请求你的API接口时，接口的请求日志非常重要，通过它可以快速的分析和定位问题。</p>
<p>我们需要把API接口的请求url、请求参数、请求头、请求方式、响应数据和响应时间等，记录到日志文件中。</p>
<p>最好有<code>traceId</code>，可以通过它串联整个请求的日志，过滤多余的日志。</p>
<p>当然有些时候，请求日志不光是你们公司开发人员需要查看，第三方平台的用户也需要能查看接口的请求日志。</p>
<p>这时就需要把日志落地到数据库，比如：<code>mongodb</code>或者<code>elastic search</code>，然后做一个UI页面，给第三方平台的用户开通查看权限。这样他们就能在外网查看请求日志了，他们自己也能定位一部分问题。</p>
<h2 id="9-幂等设计"><a href="#9-幂等设计" class="headerlink" title="9. 幂等设计"></a>9. 幂等设计</h2><p>第三方平台极有可能在极短的时间内，请求我们接口多次，比如：在1秒内请求两次。有可能是他们业务系统有bug，或者在做接口调用失败重试，因此我们的API接口需要做<code>幂等设计</code>。</p>
<p>也就是说要支持在极短的时间内，第三方平台用相同的参数请求API接口多次，第一次请求数据库会新增数据，但第二次请求以后就不会新增数据，但也会返回成功。</p>
<p>这样做的目的是不会产生错误数据。</p>
<p>我们在日常工作中，可以通过在<code>数据库</code>中增加<code>唯一索引</code>，或者在<code>redis</code>保存<code>requestId</code>和请求参来保证接口幂等性。</p>
<p>对接口幂等性感兴趣的小伙伴，可以看看我的另一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490307&idx=1&sn=b9eeb427c33cb171da6c3f11243a88f4&chksm=c0ebc3ebf79c4afd0d5a1851a975534b672d86c531d28c5933013140173e794f5f53e78a6765&token=751314179&lang=zh_CN&scene=21#wechat_redirect">高并发下如何保证接口的幂等性？</a>》，里面有非常详细的介绍。</p>
<h2 id="10-限制记录条数"><a href="#10-限制记录条数" class="headerlink" title="10. 限制记录条数"></a>10. 限制记录条数</h2><p>对于对我提供的批量接口，一定要<code>限制请求的记录条数</code>。</p>
<p>如果请求的数据太多，很容易造成API<code>接口超时</code>等问题，让API接口变得不稳定。</p>
<p>通常情况下，建议一次请求中的参数，最多支持传入500条记录。</p>
<p>如果用户传入多余500条记录，则接口直接给出提示。</p>
<p>建议这个参数做成可配置的，并且要事先跟第三方平台协商好，避免上线后产生不必要的问题。</p>
<h2 id="11-压测"><a href="#11-压测" class="headerlink" title="11. 压测"></a>11. 压测</h2><p>上线前我们务必要对API接口做一下<code>压力测试</code>，知道各个接口的<code>qps</code>情况。</p>
<p>以便于我们能够更好的预估，需要部署多少服务器节点，对于API接口的稳定性至关重要。</p>
<p>之前虽说对API接口做了限流，但是实际上API接口是否能够达到限制的阀值，这是一个问号，如果不做压力测试，是有很大风险的。</p>
<p>比如：你API接口限流1秒只允许50次请求，但实际API接口只能处理30次请求，这样你的API接口也会处理不过来。</p>
<p>我们在工作中可以用<code>jmeter</code>或者<code>apache benc</code>对API接口做压力测试。</p>
<h2 id="12-异步处理"><a href="#12-异步处理" class="headerlink" title="12. 异步处理"></a>12. 异步处理</h2><p>一般的API接口的逻辑都是同步处理的，请求完之后立刻返回结果。</p>
<p>但有时候，我们的API接口里面的业务逻辑非常复杂，特别是有些批量接口，如果同步处理业务，耗时会非常长。</p>
<p>这种情况下，为了提升API接口的性能，我们可以改成<code>异步处理</code>。</p>
<p>在API接口中可以发送一条<code>mq消息</code>，然后直接返回成功。之后，有个专门的<code>mq消费者</code>去异步消费该消息，做业务逻辑处理。</p>
<p>直接异步处理的接口，第三方平台有两种方式获取到。</p>
<p>第一种方式是：我们<code>回调</code>第三方平台的接口，告知他们API接口的处理结果，很多支付接口就是这么玩的。</p>
<p>第二种方式是：第三方平台通过<code>轮询</code>调用我们另外一个查询状态的API接口，每隔一段时间查询一次状态，传入的参数是之前的那个API接口中的id集合。</p>
<h2 id="13-数据脱敏"><a href="#13-数据脱敏" class="headerlink" title="13. 数据脱敏"></a>13. 数据脱敏</h2><p>有时候第三方平台调用我们API接口时，获取的数据中有一部分是敏感数据，比如：用户手机号、银行卡号等等。</p>
<p>这样信息如果通过API接口直接保留到外网，是非常不安全的，很容易造成用户隐私数据泄露的问题。</p>
<p>这就需要对部分数据做<code>数据脱敏</code>了。</p>
<p>我们可以在返回的数据中，部分内容用<code>星号</code>代替。</p>
<p>已用户手机号为例：<code>182****887</code>。</p>
<p>这样即使数据被泄露了，也只泄露了一部分，不法分子拿到这份数据也没啥用。</p>
<h2 id="14-完整的接口文档"><a href="#14-完整的接口文档" class="headerlink" title="14. 完整的接口文档"></a>14. 完整的接口文档</h2><p>说实话，一份完整的API接口文档，在双方做接口对接时，可以减少很多沟通成本，让对方少走很多弯路。</p>
<p>接口文档中需要包含如下信息：</p>
<ol>
<li>接口地址</li>
<li>请求方式，比如：post或get</li>
<li>请求参数和字段介绍</li>
<li>返回值和字段介绍</li>
<li>返回码和错误信息</li>
<li>加密或签名示例</li>
<li>完整的请求demo</li>
<li>额外的说明，比如：开通ip白名单。</li>
</ol>
<p>接口文档中最好能够统一接口和字段名称的命名风格，比如都用<code>驼峰标识</code>命名。</p>
<p>接口地址中可以加一个版本号v1，比如：v1&#x2F;query&#x2F;getCategory，这样以后接口有很大的变动，可以非常方便升级版本。</p>
<p>统一字段的类型和长度，比如：id字段用Long类型，长度规定20。status字段用int类型，长度固定2等。</p>
<p>统一时间格式字段，比如：time用String类型，格式为：yyyy-MM-dd HH:mm:ss。</p>
<p>接口文档中写明AK&#x2F;SK和域名，找某某单独提供等。</p>
]]></content>
      <categories>
        <category>Controller接口</category>
      </categories>
      <tags>
        <tag>Controller接口</tag>
      </tags>
  </entry>
  <entry>
    <title>django使用教程</title>
    <url>/article/ba447774.html</url>
    <content><![CDATA[<p>1、创建Django项目(在指定目录下)<br>命令：django-admin startproject 项目名</p>
<p>2、创建Django应用<br>一个项目由很多个应用组成的，每一个应用完成一个功能模块。<br>创建应用的命令如下：(进入项目文件夹中)<br>python manage.py startapp 应用名</p>
<p>3, 在django项目中配置数据库连接信息<br>‘default’: {<br>        ‘ENGINE’: ‘django.db.backends.mysql’,<br>    #数据库名（需要提前创建）<br>        ‘NAME’: ‘db_django’,<br>        #用户名<br>        ‘USER’:’root’,</p>
<pre><code>    #密码
    &#39;PASSWORD&#39;:&#39;root&#39;,
    #url 服务器地址
    &#39;HOST&#39;:&#39;localhost&#39;,
    #端口号
    &#39;PORT&#39;:3306,
&#125;
</code></pre>
<p>4,更新应用数据库<br>python manage.py makemigrations<br>python manage.py migrate</p>
<p>5,创建超级管理员<br>python manage.py createsuperuser</p>
<p>6,运行项目<br>python manage.py runserver</p>
<p>7,admin管理员页面汉化:<br>setting中修改为:<br>LANGUAGE_CODE &#x3D; ‘zh-Hans’<br>TIME_ZONE &#x3D; ‘Asia&#x2F;Shanghai’</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>flask1</title>
    <url>/article/31572391.html</url>
    <content><![CDATA[<p>Flask:<br>1,flask目录(api目录结构)</p>
<p>####1. 目录结构描述<br>├──  configs               &#x2F;&#x2F; 配置文件目录<br>│    ├──  <strong>init</strong>.py        &#x2F;&#x2F; 数据库连接，api接口，中间件等配置信息<br>│    ├──  log.py             &#x2F;&#x2F; log的输出配置文件<br>├──  core                  &#x2F;&#x2F; 封装调用方法目录<br>│    ├──  dict_config.py     &#x2F;&#x2F; 配置需要编码转换文件<br>│    ├──  db.py              &#x2F;&#x2F; 封装mysql数据库连接配置<br>│    ├──  redis_db.py        &#x2F;&#x2F; 封装redis数据库连接配置<br>├──  data                  &#x2F;&#x2F; 文件存储目录<br>├──  logs                  &#x2F;&#x2F; 日志存放目录<br>├──  schema                &#x2F;&#x2F; 和mysql数据库交互目录<br>│    ├──  models.py          &#x2F;&#x2F; ORM关系映射模板文件<br>│    ├──  deploy.sh          &#x2F;&#x2F; 生成models.py文件脚本<br>├──  test                  &#x2F;&#x2F; 测试目录<br>├──  utils                 &#x2F;&#x2F; 常用配置工具目录<br>├──  API.py                &#x2F;&#x2F; API接口主程序</p>
<p>2,返回值返回格式:<br>‘’’<br>python3<br>返回成功: return jsonify(statusCode &#x3D; 200, msg &#x3D; “”)<br>返回失败: return jsonify(statusCode &#x3D; 500, msg &#x3D; “”)</p>
<p>3,异常处理格式:<br>try:<br>    pass<br>except Exception as e:<br>    logger.error(f”xx异常:{traceback.format_exc()}行数:{e.<strong>traceback</strong>.tb_lineno}”)</p>
<p>4,项目环境打包方式:<br>安装第三方模块:<br>    pip3 install pipreqs<br>生成配置文件requirements.txt,在项目根目录下执行<br>    pipreqs .&#x2F; –encoding&#x3D;utf8 –force<br>参数说明:当要更新配置文件时,”–force”会覆盖之前生成的配置文件</p>
<p>5,flask重定向总结:<br>    1,字符串格式<br>        return “”<br>    2,response字符串格式<br>        return response(“”)<br>    3,json格式:<br>        return jsonify(msg&#x3D;””,”statusCode” &#x3D; 200)<br>        return jsonify(dict_data)<br>        return json.dumps(dict_data)<br>    4,页面跳转<br>        return render_template(“文件名”)<br>    5,重定向：实现页面跳转<br>        return redirect(user_for(“函数名”))   # 通过函数名实现页面跳转<br>        return redirect(‘&#x2F;‘)<br>        return redirect(‘url地址’)</p>
<p>6, post请求方式传参参数类型<br>    string: (缺省值)接受任何不包含斜杠的文本<br>    int: 接受正整数<br>    float: 接受征服点型<br>    path: 类似string, 但可以包含斜杠<br>    uuid: 接受UUID</p>
<p>7, postman<br>    params: 在url中添加参数,”?”用于区分,”&amp;”用于拼接.  eg: <a href="http://www.baidu.com/obj?key1=1&amp;key2=2">http://www.baidu.com/obj?key1=1&amp;key2=2</a><br>    body —&gt; form_data (传递json类型的参数,可以上传文件,文件操作), k-v的形式传参<br>    body —&gt; raw (可以传递不同格式的文件,对应的请求头分别是<br>                    text: text&#x2F;plain,<br>                    javascript: application&#x2F;javascript,<br>                    json: application&#x2F;json,<br>                    html: application&#x2F;html,<br>                    xml: application&#x2F;xml<br>                ), 字典形式传参<br>    binary: 用于二进制文件处理,eg:文件上传</p>
<p>8,请求参数的获取,post参数一般是json格式(bady–raw–json)或者表单格式(bady–from_data)<br>    ① json格式的参数获取<br>        get_data &#x3D; resquest.get_json()<br>    ② get请求参数获取<br>         if request.method &#x3D;&#x3D; “GET”:<br>            Id &#x3D; request.args.get(“id”)<br>         else:<br>            Id &#x3D; request.form.get(“id”)</p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/article/749ad7d8.html</url>
    <content><![CDATA[<p>安装:apt-get&#x2F;yum install docekr<br>查看服务状态:systemctl status docker<br>启动服务:systemctl start docker<br>拉取镜像:docker pull centos&#x2F;ubuntu<br>进入镜像:docker run -it ubuntu &#x2F;bin&#x2F;bash<br>退出:exit<br>查看所有容器:docker ps -a<br>启动容器:docker start id<br>进入容器:docker exec -it id bash<br>重启:docker restart id</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>deeplearning1</title>
    <url>/article/b6750f91.html</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_44791964/article/details/107517428">深度学习链接</a><br><a href="https://www.bilibili.com/read/cv10239076?spm_id_from=333.999.0.0">深度学习链接2</a><br>1, 查看gpu使用情况,nvidia-smi</p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>docker面试题.md</title>
    <url>/article/aeec021b.html</url>
    <content><![CDATA[<p>1, dockerfile 文件当中 copy 和 add 的区别是什么？</p>
<p>copy: 只进行复制文件和目录，不会解压归档文件或者从 url 进行下载。</p>
<p>add:  会自动解压归档文件，可以从指定 url 下载文件并添加到镜像中。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/article/4896de77.html</url>
    <content><![CDATA[<p>1, 配置全局的用户名和邮箱</p>
<p>git config –global user.name “注册的用户名”</p>
<p>git config –global user.email “注册的邮箱”</p>
<p>2,生成SSH KEY命令:ssh-keygen -t rsa -C “注册的邮箱”</p>
<p>将.ssh下的id_rsa.pub内容复制到github中</p>
<p>用户中心—&gt;settings—&gt;左侧的SSH KEYS,权限RW,点击添加按钮</p>
<p>3, 文件上传</p>
<p>git init</p>
<p>git add .</p>
<p>git commit -m “”</p>
<p>git remote add origin 远程库地址</p>
<p>git push -u origin master &#x2F; git push -f origin master</p>
<p>1,常用(上传代码)<br>git stash<br>git pull<br>git stash pop<br>git add .<br>git commit -m “”<br>git push<br>扩展:<br>git checkout 分支名:切换分支<br>git pull origin master: 拉取主分支代码<br>git merge dev: 合并dev分支代码到主分支</p>
<p><img src="https://img-blog.csdnimg.cn/eb1e2203dd17421ebbf075e02cda5e0c.png" alt="git使用"></p>
<p>1, 配置git<br>git config –global user.name “注册的用户名”<br>git config –global user.email “注册的邮箱”<br>2, 生成ssh配置文件<br>①生成SSH KEY命令:ssh-keygen -t rsa -C “注册的邮箱”<br>②将.ssh下的id_rsa.pub内容复制到github中<br>③用户中心—&gt;settings—&gt;左侧的SSH KEYS,权限RW,点击添加按钮<br>3,文件上传<br>git init<br>git add .<br>git commit -m “”<br>git remote add origin 远程库地址<br>git push -u origin master &#x2F; git push -f origin master<br>4,常用文件上传（上传到远程分支）<br>git stash<br>git pull<br>git stash pop<br>git add .<br>git commit -m “”<br>git push<br>5, 文件下载<br>git clone -b 分支名 版本库地址<br>6, git 上传代码到远程分支<br>git branch # 查看分支<br>git checkout -b 分支名 #创建并切换分支<br>git add .  #添加文件到暂存区<br>git push origin 分支名 #提交分支<br>7,  分支合并<br>git checkout master #切换到主分支<br>git merge 分支名 #合并分支到主分支</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux面试题</title>
    <url>/article/e171c965.html</url>
    <content><![CDATA[<p>1, <a href="https://blog.csdn.net/Dabie_haze/article/details/118969328?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166920428516800215048409%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166920428516800215048409&biz_id=0&utm_medium=distribute.pc_chrome_plugin_search_result.none-task-blog-2~all~top_click~default-4-118969328-null-null.nonecase&utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">常用命令</a></p>
<ol>
<li><p>ls&#x2F;ll：列出文件list</p>
</li>
<li><p>cd：切换目录change directory</p>
</li>
<li><p>cp：复制copy</p>
</li>
<li><p>mv：移动move</p>
</li>
<li><p>rm：移除，删除remove</p>
</li>
<li><p>mkdir：创建文件夹make directory</p>
</li>
<li><p>rmdir：移除，删除文件夹remove directory</p>
</li>
<li><p>chown：更改所有者change owner</p>
</li>
<li><p>chmod：更改文件的权限模式change mode</p>
</li>
<li><p>find：查找</p>
</li>
<li><p>|：管道</p>
</li>
<li><p>grep：按行查找并匹配</p>
</li>
<li><p>tar：打包，压缩，解压</p>
</li>
<li><p>cat：打印文件内容</p>
</li>
<li><p>ps：查看进程process select</p>
</li>
<li><p>kill：杀死进程</p>
</li>
<li><p>passwd：修改密码password</p>
</li>
<li><p>pwd：显示工作目录print work directory</p>
</li>
<li><p>tee：显示并保存</p>
</li>
<li><p>reboot：重启</p>
</li>
<li><p>lsof&#x2F;netstat: 查看端口 是否被占用<br>lsof -i:22<br>netstat -tunlp|grep 22</p>
</li>
<li><p>tail: 查看日志<br>实时查看:<br>tail -f 日志名<br>查看后200行日志内容<br>tail -f -n 200 demo.log  </p>
</li>
<li><p>top: 查看cpu占用率</p>
</li>
<li><p>netstat命令 – 显示网络状态</p>
</li>
</ol>
<p>2, uwsgi和nginx<br><a href="https://fies09.github.io/article/3c1ae316.html#more">详解</a><br>uwsgi: web服务器(应用服务器),用于连接Web服务器和Web应用框架<br>uwsgi启动:<br>uwsgi –ini uwsgi8001.ini<br>uwsgi重启：<br>uwsgi –reload uwsgi8001.pid<br>uwsgi停止:<br>uwsgi –stop uwsgi8001.pid<br>nginx: 是一个高性能、轻量级的http和反向代理服务器</p>
<p>3, pm2 . nohup<br>pm2: 进程管理工具<br>pm2 ls<br>pm2 start<br>pm2 stop<br>pm2 log<br>pm2 start Tasker&#x2F;schedule_task.py -x –interpreter python3  -o .&#x2F;logs&#x2F;node_task.log -e .&#x2F;logs&#x2F;node_task_error.log<br>nohup:  后台运行项目<br>保存日志:<br>nohup python3 -u Main.py &gt; nohup.log &amp;<br>不保存日志:<br>nohup python3.6 &#x2F;opt&#x2F;moss_robot&#x2F;lib&#x2F;dispatch_v5.3.2&#x2F;robot_wait.py &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</p>
<p>4, docker:<br>安装:apt-get&#x2F;yum install docekr<br>查看服务状态:systemctl status docker<br>启动服务:systemctl start docker<br>拉取镜像:docker pull centos&#x2F;ubuntu<br>进入镜像:docker run -it ubuntu &#x2F;bin&#x2F;bash<br>退出:exit<br>查看所有容器:docker ps -a<br>启动容器:docker start id<br>进入容器:docker exec -it id bash<br>重启:docker restart id</p>
<p>5,linux下如何设置,查看和注销环境变量</p>
<p>“” 设置环境变量<br>export LD_LIBRARY_PATH&#x3D;&#x2F;the&#x2F;path&#x2F;you&#x2F;want&#x2F;set<br>“” 查看设置<br>echo $LD_LIBRARY_PATH<br>“” 清除环境变量<br>unset LD_LIBRARY_PATH</p>
<p>6, 查看网卡使用的网络带宽情况</p>
<p>yum&#x2F;apt install libpcap nethogs -y</p>
<p>#使用方法</p>
<p>nethogs</p>
<p>​    # 网卡名称 DEV</p>
<p>查看指定网卡占用带宽的进程</p>
<p>nethogs 网卡名称</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>linux面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb使用</title>
    <url>/article/a7b87908.html</url>
    <content><![CDATA[<p>window下mongodb的使用:</p>
<p>MongoDB数据库:(两种方式一般使用第二种方便快捷)<br><em><strong>管理员</strong></em><br>一 ,使用流程:<br>1,启动服务器(连接):在bin目录下:mongod –dbpath “data目录”<br>2,访问(打开): <a href="http://localhost:27017/">http://localhost:27017/</a><br>3,在bin目录下输入mongo,进入数据库<br>3,进入:use admin (use进入,创建,切换)<br>3,db.shutdownServer() :关闭数据库(关闭)<br>3,访问(打开 ): <a href="http://localhost:27017/">http://localhost:27017/</a><br>{手动}</p>
<p>{自动}<br>也可直接打开:<br>二 ,升级为系统服务:<br>1, 解压zip到MongoDB64文件夹下 –&gt; 创建data和log文件夹 –&gt;在log文件夹下创建MongoDB.log文件–&gt; 进入bin目录 –&gt; 输入 mongod –dbpath “data目录” –logpath “MongoDB.log目录及名称” –install -serviceName “MongoDB”<br>将服务手动启动:net start MongoDB&#x2F;net stop MongoDB<br>2,在bin目录下输入mongo,进入数据库<br>3,use 数据库名 :切换&#x2F;创建数据库<br>4,db:查看当前所在的数据库<br>5,show dbs:查看当前MongoDB数据库中的所有数据库<br>6,在数据库中创建一个集合(表)movie并插入一条记录<br>db.movie(表名).insert({name:”mymovie01”})(记录)<br>7,当数据库中没有数据库对象(数据)时,show dbs 不会显示<br>8,删除数据库:db.dropDatabase():删除当前所在的数据库<br>9,集合的创建(数据表的创建)(与上述区别,没插入数据)<br>db.createCollection(name)<br>10,show collections:显示所有集合<br>11,索引的元信息存储在每个数据库的system.indexes集合中,不能插入删除<br>12,集合的删除操作db.集合名.drop()<br>13,数据类型:<br>String:字符串(utf8)<br>Integer:整数<br>Boolean:布尔型:(true&#x2F;false)<br>Double:浮点型(小数)<br>Min&#x2F;Max keys:最低和最高值比较<br>Arrays:多个值放到一个key中<br>Timestamp:时间戳<br>Object:此数据类型用于嵌入式文件(1 v 1,1 v多,多 v 1, 多 v 多)<br>Null:空值<br>Symbol:通常保留给特定符号类型的语言,此数据类型用于字符串相同<br>Date:日期<br>Object ID:文档(表,集合)ID<br>Binary data :二进制数据<br>Code:用于存储到文档中的js代码<br>Regular expression:正则表达式</p>
<p>文档对象的增查更删:<br>增加:<br>①db.文档名.insert([{k1:v1},{k2:v2}])<br>②var docs &#x3D; [{k1:v1},{k2:v2}]<br>db.文档名.insert(docs)<br>查看文件结构:db.文档名.find()</p>
<p>查:<br>db.集合名.find() :查询所有<br>db.集合名.findOne() :返回集合中的第一条文档数据<br>db.集合名.find().pretty() :结构化显示数据<br>条件查询:<br>db.集合名.find(k:”v”).pretty()<br>小于:$lt  小于等于:$lte<br>大于: $gt     大于等于:$gte<br>不等于:$ne<br>db.集合名.find({k:{$ne:v}}).pretty()</p>
<p>AND&#x2F;OR<br>AND<br>db.集合名.find({k1:”v1”,k2:”v2”}).pretty()<br>OR<br>db.集合名.find({$or:[{k1:”v1”},{k2:”v2”}]}).pretty()<br>大于并且..或..<br>db.集合名.find({k1:{$gt:v1},$or:[{k2:”v2”},{k3:”v3”}]}).pretty() </p>
<p>更新(修改):<br>Criteria:更新操作条件,类似sql语句中的where子句<br>ObjNEW:更新的操作符::(如$,$inc…),也可以理解为sql update查询内set后面的<br>Upsert:如果不存在update的记录,是否插入objNEW,true为插入,默认是false,不插入<br>Multi:默认是false,只更新找到的第一条记录,如果这个参数为true,就把按条件查出来<br>多条记录全部更新<br>db.集合名.update({k1:”v1”},{$set:{k2:”要修改的值”}},false,true)</p>
<p>删除:<br>remove:db.infos.remove({k1:”v1”})<br>deletion criteria(可选):<br>justOne(可选):<br>投影(不显示0,1显示):db.infos.find({},{k1:0,k2:0,k3:0}).pretty()</p>
<p>限制记录limit()<br>只显示n个记录:db.infos.find().limit(n)<br>先跳过m条记录,然后显示n条记录:db.infos.find().limit(n).skip(m)</p>
<p>组合使用(限制记录+分页处理):n –&gt; 显示文档个数  m –&gt; 文档个数(页数 - 1)<br>Skip()+Limit():分页显示<br>db.infos.find().limit(n).skip(m)</p>
<p>排序:1:升序(小到大)  -1:降序(大到小)<br>db.infos.find().sort({key:-1}).pretty()</p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/article/fe4ef317.html</url>
    <content><![CDATA[<p>1, 安装deb</p>
<p>dpkg -i 文件名</p>
<p>2, window与liunx的shell脚本编码问题<br>修改编码:<br>vim 文件名<br>esc :<br>set ff&#x3D;unix<br>esc : wq</p>
<p>查看编码<br>esc :<br>set ff</p>
<p>3, 解决vmware tools失效<br>sudo apt-get autoremove open-vm-tools    &#x2F;&#x2F;卸载已有的工具<br>sudo apt-get install open-vm-tools        &#x2F;&#x2F;安装工具open-vm-tools<br>sudo apt-get install open-vm-tools-desktop  &#x2F;&#x2F;安装open-vm-tools-desktop<br>重启: init 0&#x2F;reboot</p>
<p>4, 查看进程：ps -ef | grep 文件名<br>杀死进程：kill -9 id</p>
<p>5, shell文件运行命令<br>chmod +x .&#x2F;auto_download.sh &amp;&amp; .&#x2F;auto_download.sh</p>
<p>6,定时器<br>cat &#x2F;etc&#x2F;crontab</p>
<p>Ubuntu:<br>1, 安装防火墙<br>sudo su<br>apt-get install firewalld<br>查看状态<br>systemctl status firewalld<br>2,乌班图源的处理:<br><a href="https://blog.csdn.net/wssywh/article/details/79216437">pip源和软件源处理</a><br>3,安装deb文件<br>dpkg -i xxx.deb<br>3,定时任务<br>待测: cat &#x2F;etc&#x2F;corntab<br>①先创建py文件<br>②在py文件下输入crontab -e<br>③设置执行时间间隔<br><img src="https://img-blog.csdnimg.cn/d8720c2d022a485985c260796741466e.jpeg" alt="文件内容"><br><img src="https://img-blog.csdnimg.cn/f874919abf8145c88291ce275a54b608.jpeg" alt="常见的时间设置"><br>4,端口&#x2F;进程查看<br>查看端口是否占用<br>lsof -i:22<br>netstat -tunlp|grep 22<br>查看进程<br>ps aux|grep API.py<br>杀死进程<br>kill -9<br>5,实时查看日志<br>tail -f demo.log</p>
<p>查看后200行日志内容</p>
<p>tail -f -n 200 demo.log<br>6,服务器启动<br>nohup python3 &#x2F;opt&#x2F;moss_robot&#x2F;lib&#x2F;dispatch_v5.3.2&#x2F;robot_wait.py &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>7,shell脚本运行<br>chmod +x .&#x2F;start.sh &amp;&amp; .&#x2F;start.sh</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础</title>
    <url>/article/8e40d0ad.html</url>
    <content><![CDATA[<p>总结<br>    有关数据库的DDL操作<br>    - SHOW DATABASES;<br>    -CREATE DATABASES 数据库名;<br>    -DROP DATABASES [IF EXISTS]数据库名;<br>    -USE 数据库名;</p>
<pre><code>有关数据表的DDL操作
-SHOW TABLES;
-DESC 表名;
-CREATE TABLES 表名(......);
-DROP TABLE 表名;
-ALTER TABLE  表名;

数据表的列类型
-数值类型:INT,FLOAT
-日期类型:DATE,TIME
-字符串类型:CHAR,VARCHAR,TEXT
</code></pre>
<p>一,<br>库操作<br>①show databases;  查询当前用户下所有数据库</p>
<p>②create database 数据库名;  创建数据库</p>
<p>③use 数据库名;    打开库(包括切换其他数据库)</p>
<p>④show tables;     显示当前数据库下所有的数据表</p>
<p>⑤drop database 数据库名;  删除数据库</p>
<p>⑥desc 表名;(dos下)      显示表结构</p>
<p>float(7,2)——-整数部分99999     99999.99</p>
<p>char(4):  不可变字符串长度3位<br>varchar(4),可变数据长度</p>
<p>二,<br>表操作<br>①create table 表名(id int);   建表<br> create table demo3(id int,username varchar(20),userpass varchar(20),ctime datetime);</p>
<p>float(7,2)—- 整数值99999  最大值99999.99</p>
<p>char(4)<br>abc<br>verchar(4)<br>ab</p>
<p>②drop table 表名;      删除数据表</p>
<p>③alter<br>添加字段<br>alter table 表名 add 字段名 数据类型;    [单字段]<br>alter table demo1 add name varchar(20);    </p>
<p>alter table 表名 add(字段1 数据类型,字段2 数据类型…);    [多字段]<br>alter table demo1 add(dates date,flag int);</p>
<p>insert into 表名 values(字段1值,,字段2值)</p>
<p>⑤drop<br>alter table 表名 drop 字段名;    删除字段</p>
<p>④modify<br>修改字段 (原表中已存在的,不修改列名)<br>alter table 表名 modify 字段名 字段类型;        [单字段]<br>alter table demo1 modify flag char(1);</p>
<p>alter table 表名 modify 字段名1 字段类型1,modify 字段名2 字段类型2…;        [多字段]<br>alter table demo1 modify flag char(1);</p>
<p>⑥<br>重命名字段<br>alter table 表名 change 旧字段名 新字段名 字段类型;</p>
<p>重命名表名<br>alter table 表名 rename 新表名;<br>rename table 表名 to 新表名;</p>
<p>删除表数据(表截断),保留结构,清除表中所有数据,不清选择性删除,不能回退<br>truncate 表名;       </p>
<p>三,约束<br>数据库约束概念:在数据表上强制执行的效验规则,保证了数据的完整性<br>(唯一约束,主键约束,外键约束会自动创建索引,非空约束不会,)</p>
<p>非空约束 :<br>建立数据表字段中使用或者在修改数据表字段中使用 ,      格式: 字段名 字段类名 约束名<br>不等于null :空字符串,0,’null’,null不区分大小写,主键或非空不为null<br>创建,修改<br>create table 表名(字段名 字段类型 not null);     不填可默认为null<br>create table 表名(id int not null);</p>
<p>alter table 表名 modify 字段名 字段类型 约束名;<br>alter table demo1 modify url text not null;</p>
<p>alter table 表名 drop 字段名;    删除字段<br>alter table demo drop id;</p>
<p>唯一约束:<br>建立在not null 前<br>.修改,<br>不出现重复值,允许出现多个NULL,同一张表可有多个唯一约束,可由多列组合而成,会为之建立对应的索引,若不给唯一约束起名.该唯一约束默认与列名相同,<br>alter table 表名 modify 字段名 字段类型 unique;<br>alter table demo modify id int unique;</p>
<p>alter table 表名 drop 字段名;      删除唯一约束 (必须有多个字段)<br>alter table demo drop id;</p>
<p>主键约束<br>相当于 非空约束 + 唯一约束   唯一确定一行记录的字段或字段组合<br>注意.一张数据表中只能有一个主键<br>创建<br>create table 表名(字段名1 字段类型1 primary key,字段名2 字段类型2);<br>create table demo5(id int primary key,name varchar(20));</p>
<p>alter table 表名 drop primary key; 删除主键</p>
<p>alter table 表名 modify 字段名 字段类型 primary key;<br>alter table demo5 modify id int primary key; 修改主键 [将非主键字段修改为 主键字段]</p>
<p>create table 表名(字段名1 字段类型1,字段名2 字段类型2,primary key(字段名1,字段名2 ));<br>create table demo6(id int,name varchar(20),primary key(id,name)); 两个字段共用一个主键.复合主键</p>
<p>create table 表名(主键名 主键类型 primary key auto_increment,字段名2 字段类型2);<br>create table demo6(id int primary key auto_increment,name varchar(20));主键自增,在primary key 后加上auto_increment</p>
<p>insert into 表名(字段名) values(字段值); [主键自增时增加字段内容]<br>insert into demo6(name) values(‘zs’);</p>
<p>外键 约束([一对一,可选择任意一方来增加外键列,只要为外键列增加唯一约束就可],[一对多,在多的一端增加外键列])<br>有外键的为从表,没有的为主表,保证两个数据表间的参照关系<br>创建<br>先创建主表<br>create table 主表名(主键名 主键类型 primary key,字段名2 字段类型2);<br>create table dept(deptno int primary key,dname varchar(20));</p>
<p>再建从表<br>create table 从表名(从表主键名 从表主键类型 primary key,字段名2 字段类型2,主表主键名 主表主键类型,constraint 从表名_fk foreign key(主表主键名) references 主表名(主表主键名));    从表名_fk:自定义的约束名<br>create table emp(empno int primary key,ename varchar(20),sal int,deptno int,constraint emp_fk  foreign key(deptno) references dept (deptno));</p>
<p>删除外键约束<br>①删除外键<br>alter table 从表名 drop foreign key 约束名;<br>alter table emp drop foreign key emp_fk;emp_fk,约束名</p>
<p>②删除外键索引<br>alter table 从表名 drop index 约束名;<br>alter table emp drop index emp_fk;</p>
<p>增加外键<br>alter table 从表名 add foreign key(主表主键) references 主表名(主表主键名);references 参照表及其主键(主表的主键)<br>alter table emp add foreign key(deptno) references dept(deptno);</p>
<p>检查约束:保证数据的输入校验规则(oracle支持,mysql 不支持)<br>create table 表名(id int check(id in (1,2)));<br>插入数据时只能输入1或2<br>create table 表名(age int check(age&gt;8));<br>插入数据时只能是大于8的数据</p>
<p>show create table 表名;查询建表结构</p>
<p>DML语句,数据操作语言<br>插入,修改,删除语句</p>
<p>插入数据:向新行中写入insert<br>insert into 表名(字段名…) values(值…)  指定插入字段,如果字段名没写,默认值为NULL<br>insert into demo1(id,name,url) values(1,’zs’,’test’);<br>insert into demo1(name,url) values(‘zs’,’test’);</p>
<p>insert into 表名 values(值…)  默认插入所有字段<br>insert into demo1 values(1,’zs’,’test’);</p>
<p>插入多条记录(行)<br>insert into 表名 values(值…),(值…);<br>insert into demo1 values(4,’zs’,’test’),(5,’aa’,’test’);</p>
<p>修改&#x2F;更新数据update<br>update 表名 set 需要修改的字段 &#x3D; 新值;</p>
<p>[单个修改]<br>[多条记录]update 表名 set 需要修改的字段 &#x3D; 新值;<br>update demo1 set url &#x3D; ‘a’;</p>
<p>[多个字段值修改]<br>update 表名 set 需修改的字段1 &#x3D; 新值1,需修改的字段2 &#x3D; 新值2;</p>
<p>[根据条件修改]<br>update 表名 set 需要修改的字段 &#x3D; 新值 where 条件;<br>update demo1 set name &#x3D; ‘test’ where id &#x3D; 4;</p>
<p>删除delete from<br>[单条删除]<br>delete from 表名 where 条件;<br>delete from demo1 where name &#x3D; ‘zs’;<br>[多条删除]<br>delete from 表名;<br>delete from demo1;</p>
<p>DQL数据库查询语言<br>查询<br>select 字段列表 from 表名;[查询指定行数据]<br>select name from demo1;<br>select * from 表名;[查询所有行数据]<br>select * from demo1;</p>
<p>算术运算符:+-*&#x2F;<br>为字段名起别名 格式:字段名 as 别名(使用双引号)<br>select name,sal + 500 as “sals” from demo1;<br>注意:as可以省略,双引号可以省略(在别名中出现空格时不能省略)<br>select name,sal + 500 sals from demo1;</p>
<p>去重:distinct<br>a,单字段去重<br>select distinct 字段名 from 表名;<br>b,组合字段去重<br>select distinct 字段名1,字段名2… from 表名;</p>
<p>not &gt; and &gt; or</p>
<p>limit 取数据记录<br>limit n —–记录数<br>limit n,m n—起始索引  (从0开始) m—-记录数</p>
<p>大多数 用于分页<br>select * from 表名 limit n;</p>
<p>数据排序<br>格式: order by 字段名;(查询 语句 结尾)<br>—升序:asc[默认]<br>select * from 表名 order by 字段名;<br>eg:select * from demo1 order by sal asc; 按工资升序排列<br>—降序 :desc<br>select * from 表名 order by 字段名 desc;<br>eg:select * from demo1 order by sal desc; 按工资 降序排列<br>—组合排序<br>select * from demo1 order by sal,name desc;按照第一个字段排序,如果有重复数据则按照第二个字段排序<br>select * from 表名 order by 字段名1 排序类型1,字段名2 排序类型2;</p>
<p>—别名排序<br>select 字段名1,对字段名2修改 字段名2修改的别名 from 表名 order by 字段名2修改的别名;一般情况是为生成的新字段数据,执行排序操作<br>eg: select name,sal+200 sals from demo1 order by sals;</p>
<p>索引<br>作用:用于提高数据表查询效率<br>创建索引:<br>自动:由数据库自动完成,通过创建主键约束 ,唯一约束,外键约束会自动建立索引<br>手动:<br> create index i_name on demo1(name);<br>格式:create index 索引名 on 表名(字段…);<br>create index i_us on demo1(url,sal);组合索引</p>
<p>删除索引<br>drop index 索引名  on 表名;<br>drop index i_us on demo1;</p>
<p>alter table 表名 drop index 索引名<br>alter table demo1 drop index i_name;</p>
<p>函数<br>字符串<br>concat(‘a’,’b’);连接ab.一般是select查询<br>数值<br>mod(1,3);1&#x2F;3的余数<br>select ceil(0.8);1 —-ceil向上取整   ceil(-0.8);0<br>select floor(0.8);0 —floor向下取整  floor(-0.8);-1<br>截断<br>select truncate(3.21,2);—3.21<br>select truncate(3.21,1);—3.2<br>当前日期<br>select curdate();<br>当前时间<br>select curtime();<br>当前时间日期<br>select now();<br>一般计算年龄:<br>select dates,year(now())-year(dates)  age from demo1;</p>
<p>select ifnull(1,2);1<br>select ifnull(数据1,数据 2);如果数据1为null,返回数据2,否则返回数据1</p>
<p>select nullif(3,2);3<br>select nullif(数据1,数据2);如果数据1和数据2相等,返回null,否则返回数据1</p>
<p>select name,sal,if(sal,’有值’,’空值’) result from demo1;<br>if(数据1,数据2,数据3);如果数据1 为true,返回数据2,否则返回数据3</p>
<p>select isnull(sal) from demo1;0表示false.1表示true(是不是空值,如果是空值true,不是空值false)<br>isnull(数据1);判断数据1是否为null,如果为null返回true,否则返回false</p>
<p>select version();显示数据库当前版本<br>select database();显示当前数据库名<br>select password(‘123’);123字符password加密的方式<br>select md5(‘123’);字符123md5加密的方式</p>
<p>多行函数(聚合函数)   除 count外 都会 忽略null的值<br>avg():平均值<br>count():统计行数<br>max():求最大值<br>min():求最小值<br>sum():求和<br>select avg(sal),max(sal),min(sal),sum(sal) from demo1;</p>
<p>where + group by + order by</p>
<p>数据分组 group by<br>select deptno,avg(sql) from emp group by deptno;从员工 表中依据部门编号分组查询部门编号 —-分组查询</p>
<p>分组排序<br>select deptno,(ename,)avg(sql) avgs from emp group by deptno order by avgs desc;</p>
<p>where 和having 的区别<br>where 只能用在表名后<br>having用在group by 后</p>
<p>分组排序 加条件<br>查询平均工资大于1500的部门<br>select deptno,avg(sql) avgs from emp group by deptno having sal &gt; 1500  order by avgs desc;</p>
<p>select deptno,sum(sal) sums from emp where sal &gt; 1500 group by deptno; </p>
<p>select deptno,sum(sal) sums from emp where sal &gt; 1500 group by deptno having sums &gt;3000;</p>
<p>select deptno,sum(sal) sums from emp where sal &gt; 1500 group by deptno having sums &gt;3000 order by sums;<br>{<br>    DQL:数据库查询语言<br>    主要由SELECT . WHERE,ORDER BY,GROUP BY,和HAVING关键字构成</p>
<pre><code>DML:数据操作语言
主要由insert,update,和delete三个关键字完成,对数据库记录修改

DDL:数据定义语言
主要由create,alter和drop和truncate四个关键字完成

DCL:数据控制语言
主要由grant和revoke关键字完成

TPL:事务处理语言
主要由commit,rollback,transaction关键字完成
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本使用</title>
    <url>/article/d4fee3ae.html</url>
    <content><![CDATA[<p>1, <a href="https://nodejs.org/en/download/">下载nodejs</a></p>
<p>2,  下载淘宝镜像</p>
<p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>3, 下载hexo</p>
<p>cnpm install -g hexo-cli</p>
<p>4, 建立文件夹,生成博客</p>
<p>mkdir blog</p>
<p>cd blog </p>
<p>hexo init</p>
<p>下载next主题: </p>
<p>git clone <a href="https://github.com/litten/hexo-theme-next.git">https://github.com/litten/hexo-theme-next.git</a> themes&#x2F;next</p>
<p>在github上建立仓库: </p>
<p>github名.github.io</p>
<p>安装git相关模块<br>npm install –save hexo-deployer-git</p>
<p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#x2F;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql面试题</title>
    <url>/article/c45230cb.html</url>
    <content><![CDATA[<p>1, mysql索引<br><a href="https://www.cnblogs.com/jiuya/p/10023483.html">mysql索引的详细说明</a><br>普通索引:<br>是最基本的索引,没有任何限制<br>唯一索引:<br>索引列的值必须唯一,但允许有空值,如果是组合索引,则列值的组合必须唯一<br>主键索引:<br>一个表只能有一个主键,不允许有空值,一般在建表的同时创建主键索引<br>组合索引:<br>指多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用.使用组合索引时遵循最左前缀集合<br>全文索引:<br>主要是用来查找文本中的关键字,而不是直接与索引中的值相比较.</p>
<p>2, 数据库优化<br>①,如有条件,数据可以存放于redis,读取速度快,<br>②,建立索引,外键等<br>③使用联合来代替手动创建的临时表<br>④使用事物<br>⑤使用锁定表<br>⑥选取合适的字段属性<br>⑦使用连接代替子查询</p>
<p>3,创建数据库的四大原则?<br>答:<br>事物: 是数据库操作的最小工作单元,是一组不可再分割的操作集合<br>原子性: 整个程序中的所有操作,要么全部完成,要么全部不完成,不可能停滞在中间某个环节<br>一致性: 倘若事物操作失败,则回滚事物时,与原状态一致.<br>隔离性: 当在进行事物操作时, 其他事物的操作不可能影响当前事物操作,事物与事物之间是隔离的,互不干扰,干完再整合.<br>持久性: 事物的操作具有持久性, 事物结果一旦写入数据库,在不改动的情况下,数据库一直都是这个数据.</p>
<p>4,orm数据库?<br>orm数据库:称为对象–关系映射,主要实现模型对象到关系数据库数据的映射,把数据表中的每一条记录映射为一个模型对象,</p>
<p>5,数据表student有id,name,score,city字段,其中name中的名字可有重复,需消除重复行,请写sql语句<br>答:select distinct name from student;</p>
<p>6, 表合并<br>①<br>#sql union 不允许重复的值<br>select 字段名 from 表名 union select 字段名2 from 表名2</p>
<p>#sql union all 允许重复的值<br>elect 字段名 from 表名 union all select 字段名2 from 表名2</p>
<p>②<br>insert into 表1 select * from 表2</p>
<p>7,数据库优化查询方法<br>答:外键,索引,联合查询,选择特定字段等等</p>
<p>8,写5条常用sql语句<br>答:show databases;<br>show tables;<br>desc tb_name;<br>select * from tb_name<br>delete from tb_name where id &#x3D; 5;<br>update tb_name set name&#x3D;’xue’,age&#x3D;23 where id &#x3D; 5;</p>
<p>9, <a href="https://fies09.github.io/article/8e40d0ad.html?highlight=mysql">mysql</a><br>排序: order by<br>分组: group by<br>条件: where<br>where 和having 的区别<br>where 只能用在表名后<br>having用在group by 后</p>
<p>10,列出常见mysql数据存储引擎<br>InnoDB:支持事物处理,支持外键,支持崩溃修复能力和并发控制.<br>MyISAM:插入数据快,空间和内存使用比较低,<br>MEMORY:所有数据都在内存中,数据的处理速度快.但是安全性不高</p>
<p>11,Mysql数据库的隔离级别<br>①Read Uncommitted(读取末提交内容)<br>在该隔离级别,所有事物都可以看到其他末提交事物的执行结果,本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>②Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>③Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（PhantomRead）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。<br>④Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<p>12, mysq与redis,mongodb的区别<br>mysql: 关系型数据库,数据保存在磁盘中,速度慢<br>redis: 内存型非关系数据库,数据保存在内存中, 速度快<br>mongodb: 非关系型数据库,虚拟内存加持久化存储,有独特的mongodb查询方式</p>
<p>13, join<br>inner jon 内连接<br>内连接又叫等值连接，此时的inner可以省略。<br>获取两个表中有匹配关系的记录，即两表取交集<br>select * from a join b on a.’name’ &#x3D; b.’name’<br>left join 左连接<br>以左表为基础，获取匹配关系的记录，如果右表中没有匹配项，NULL表示<br>select * from a left join b on a.’name’&#x3D;b.’name’<br>right join 右连接<br>以右表为基础，获取匹配关系的记录，如果左表中没有匹配项，NULL表示<br>select * from a right join b on a.’name’&#x3D;b.’name’</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>mysql面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>python第三方模块整理</title>
    <url>/article/f6e83c4a.html</url>
    <content><![CDATA[<p>1.必装模块pypiwin32 wheel:主要是为了装whl文件</p>
<p>2,pyinstaller:将python文件转化为exe文件<br>进入py文件目录下:cmd —&gt;pyinstaller -F 文件名.py</p>
<p>3,虚拟机教程<br>安装:pip install -U virtualenv<br>设置虚拟路径:virtualenv -p d:\dev\python\python36\python.exe\py36<br>进入虚拟环境:cd py36\scripts<br>启动:activate</p>
<p>4,pip文件的配置<br>pip文件的配置</p>
<p>内容:<br>[global]<br>index-url&#x3D;<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>5, pyc文件的编译<br>python -m py_compile 文件名.py<br>pyo文件的编译:<br>python -O -m py_compile 文件名.py</p>
<p>6,Beautiful Soup:<br>用于数据收集的Python库:<br>这个是一个HTML和XML解析器,可用于从web页面中提取数据,这个过程叫做网页抓取</p>
<p>7,Scrapy:这是一个用于大规模网页抓取的框架,提供所有需要的工具有效的从网站中抓取数据,以使用者偏好的结构和格式存储数据</p>
<p>8,Selenium:这是一个倍受欢迎的自动化浏览器工具,在业界常用于测试,但对于网页抓取也非常方便</p>
<p>9,**用于数据清理和数据操作的Python库<br>**<br>pandas:主要用于数据操作和数据分析</p>
<p>10:numpy:这是一个开源库,引入了支持大型多维数组和矩阵的函数</p>
<p>11,PyOD:一个全面的,可伸缩的Python工具包,用于检测外围对象</p>
<p>12,用于数据可视化的Python库<br>Matplotlib:这是Python中最流行的数据可视化库,允许生成和构建各种各样的图</p>
<p>13,Seaborn:另一个基于Matplotlib的绘图库为绘制有吸引力的图像而提供高级接口</p>
<p>14,用于建模的Python库<br>Scikit-learn:它是Python建模中的佼佼者,支持机器学习中执行的不同操作,如分类,回归,聚类和模型选择等</p>
<p>15,Tensorflow:这是一个流行的深度学习库,提供模型构建,机器学习生产及强大的实验工具和库</p>
<p>16,用于数据解释型的Python库<br>LIME:这是一种算法(库),可以解释任何分类器或回归量的预测</p>
<p>17,H2O:通过可视化提供机器学习可解释性(MLI)说明建模结构和模型中特征的影响</p>
<p>18,用于音频处理的Python库:<br>LibROSA:一个用于音乐和音频分析的Python库,提供了创建音乐信息检索系统所需的构建块</p>
<p>19,pyAudioAnalysis:一个用于音频特征提取,分类和分段的Python库,涵盖广泛的音频分析任务</p>
<p>20,用于图像处理的Python库<br>OpenCV-Python:用于图像处理的Python API,主要用于解决计算机视觉问题</p>
<p>21,Scikit-image:可执行多个不同图像处理任务的算法集合,用于图像分割,几何变换,色彩空间操作等等</p>
<p>22,Pillow:它是从Python Imaging Library 中派生出来的,可以执行逐像素操作掩模和透明处理等等</p>
<p>用于部署的Python库<br>23,django:Python web框架的先驱,大而全,功能及其强大,非常适合企业级网站的开发</p>
<p>24,flask:一个用Python编写的Web框架,小巧,灵活,非常适用于小型网站</p>
]]></content>
      <categories>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>第三方库</tag>
      </tags>
  </entry>
  <entry>
    <title>python关键字整理</title>
    <url>/article/4321eec9.html</url>
    <content><![CDATA[<p>一,各个关键字代表的含义</p>
<p>abs():取元素绝对值<br>np.array():表示数组<br>np.argsort():返回元素排序的下标位置(针对索引)<br>np.sum():求和(针对数组)<br>np.sqrt():开平方<br>np.mean():求平均值<br>np.stu():求标准差<br>loadtxt:读取文件(属性如下)<br>delimiter &#x3D; “,”:分隔符<br>skiprows &#x3D; 1:空除第一行<br>usecols&#x3D;(17,13,2):分别使用第17,13,2列<br>c:collections<br>c.Counter(sortlabel[0:k]).most_common(1)[0][0]:出现次数最多的元素<br>.print:输出<br>ord():将字符转化为ASCII<br>char():将ASCII转换为字符串<br>bin():十 — 二<br>oct():十 — 八<br>hex():十 — 十六<br>eval():十六 — 十<br>int():其他 — 十<br>list.sort():列表排序<br>str(字符串).split(‘,’):以逗号分隔<br>%s:字符串 %d:整数<br>%f:小数<br>sorted(内容):所有可迭代的对象<br>list.sort(reverse&#x3D;True):降序排列<br>content.decode(“编码类型”):编码<br>content.encode(“编码类型”):解码<br>+:同类型拼接<br>print(“姓名：{0} 年龄：{1}”.format(‘zs’,age))<br>print(“姓名:%s 年龄:%d” %(‘ct’,35)) #%f[小数（浮点数）] %s [字符串]<br>%d [整数]</p>
<p>import os<br>os.system(‘cls’):清屏<br>os._exit(0):退出<br>choice.lower() &#x3D;&#x3D; ‘y’:输入的字母为小写y,一般用于条件判断</p>
<p>import time<br>time &#x3D; time.strftime(“%Y%m%d%H%M%S”,time.localtime()):当前时间<br>time.sleep(秒数):延迟<br>time.time():当前时间</p>
<p>continue:跳出循环,重复操作<br>break:跳出循环:进行下一步操作<br>end &#x3D; “” :不换行,输出为一行</p>
<p>import getpass (暂时无法实现)<br>password &#x3D; getpass.getpass(‘要输入的密码’):密码隐藏</p>
<p>arr.shape:查看数组几行几列<br>arr.dtype:数组的数据类型<br>ur.urlretrieve():将文件下载到本地进度条<br>.print:输出</p>
<p>map用法:<br>1,定义一个函数,<br>def square(x): #计算平方数<br>return x ** 2<br>map(函数名(square),一个或多个序列(列表))<br>#计算列表中的元素平方</p>
<p>2,使用lambda匿名函数<br>map(lambda x: x **2 ,序列(列表))<br>#计算列表中的元素平方</p>
<p>3,提供了两个列表.对相同位置的数据进行相加<br>map(lambda x,y:x+y,[1,3,1,4,5,2,1],[1,0,1,0,1,0,9])</p>
<p>enumerate:指定列表元素下标并输出,一般用于for循环<br>start指定下标开始位置,默认为0<br>eg:<br>seq &#x3D; [‘one’,’two’,’three’]<br>for i , element in enumerate(seq,start &#x3D; 2):<br>print(i,element)<br>#2 one<br>#3 two<br>#4 three</p>
<p>&#x3D;:赋值<br>&#x3D;&#x3D;:判断是否相等(在if中使用)</p>
<p>都和numpy有关<br>在灵活的包装器np.(add, sub, mul, div, mod, pow)算术运算符:+，-，<em>，&#x2F;，%，</em>*</p>
<p>1,数据类型<br>bool:布尔型(True,False)<br>int:整型(整数)<br>float:浮点型(小数)<br>complex:复数</p>
<p>2,进制转换<br>bin():将给的参数转化成二进制<br>oct():将给的参数转换成八进制<br>hex():将给的参数转换成十六进制</p>
<p>3,数学运算<br>abs():返回绝对值<br>divmode():返回商和余数<br>round():四舍五入<br>sum():求和<br>pow(a,b):求a的b次幂,如果有三个参数,则求完次幂后对第三个数取余<br>min():求最小值<br>max():求最大值</p>
<p>1,序列<br>1).列表和元组<br>list():将一个可迭代对象转换成列表<br>tuple():将一个可迭代对象转换成元组<br>2).相关内置函数<br>reversed():将一个序列翻转,返回翻转序列的迭代器<br>slice():列表的切片<br>3).字符串<br>str():将数据转化成字符串<br>bytes():把字符串转化成bytes类型<br>ord():输入字符找带字符编码的位置<br>chr():输入位置数字找出对应的字符<br>ascii():是ascii码中的返回该值,不是就返回u<br>repr():返回一个对象的string形式</p>
<p>2.数据集合<br>字典:dict创建一个字典<br>集合:set创建一个集合</p>
<p>3.相关内置函数<br>len():返回一个对象中的元素的个数<br>sorted():对可迭代对象进行排序操作(lamda)<br>lterable:可迭代对象<br>reverse:是否是倒叙,True:倒叙,False:正序<br>enumerate():获取集合的枚举对象</p>
<p>key:排序规则(排序函数)<br>all():可迭代对象中全部是True,结果才是True<br>any():可迭代对象中有一个是True,结果就是True<br>fiter():过滤(lamda)<br>map():会根据提供的函数对指定序列做出映射(lamda)<br>zip():用于将可迭代对象作为参数</p>
<p>和作用域有关:<br>locals():返回当前作用域中的名字<br>globals():返回全局作用域中的名字</p>
<p>和迭代器生成器相关:<br>range():生成数据<br>iter():获取迭代器,内部实际使用的是__iter__()方法来获取迭代器<br>next():迭代器向下执行一次,内部实际使用了__next__()方法返回迭代器的下一个项目</p>
<p>字符串类型代码的执行:<br>eval():执行字符串类型的代码,并返回最终结果<br>exec():执行字符串类型的代码<br>compile():将字符串类型的代码编码,代码对象能够通过exec语句来执行或者eval()进行求值</p>
<p>输入输出:<br>print():打印输出<br>input():获取用户输入的内容</p>
<p>内存相关:<br>hash():获取到对象的哈希值(int,str,bool,tuple)</p>
<p>文件操作相关:<br>open():用于打开一个文件,创建一个文件句柄</p>
<p>模块相关:<br>import():用于动态加载类和函数</p>
<p>帮助:<br>help():函数用于查看函数或模块用途的详细说明</p>
<p>调用相关:<br>callable():用于检查一个对象是否是可调用的,</p>
<p>查看内置属性:<br>dir():查看对象的内置属性,访问的是对象中的__dir__()方法</p>
<p>strip():去除指定字符&#x2F;默认去除空格</p>
<p>1,分片[::]:起始,末尾(不包含),步长—-&gt;取末尾的前一个<br>[:]:取所有<br>[::-1]:从后往前取所有</p>
<p>2,表达式,运算符<br>表达式&#x3D;操作数+运算符<br>运算符:7个<br>算术运算符:<br>+(加) -(减) *(乘) &#x2F;(除) %(求余) &#x2F;&#x2F;(整除)</p>
<p>比较运算符:&#x3D; &lt; &gt;</p>
<p>逻辑运算符:and not or</p>
<p>成员运算符:in not in</p>
<p>身份运算符:is is not</p>
<p>#详细说明(代码实现位运算符)<br>位运算符: &lt;&lt; 左移 &gt;&gt; 右移</p>
<p>异或:^</p>
<p>创建:virtualenv 虚拟环境名<br>开启: source activate</p>
<p>1，占位符</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%d</span>是整数的占位符，<span class="variable">%f</span>是小数的占位符（<span class="variable">%.nf</span>，n表示保留n位小数）<span class="punctuation">,</span><span class="variable">%s</span>是字符串占位符</span><br></pre></td></tr></table></figure>

<p>2，格式转换</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）</li>
</ul>
<p>3，分支结构</p>
<p>if xx:</p>
<pre><code>pass
</code></pre>
<p>elif xx：</p>
<pre><code>pass
</code></pre>
<p>else:</p>
<pre><code> pass
</code></pre>
<p>4, 循环结构</p>
<p><code>for-in</code>循环，一种是<code>while</code>循环</p>
<p>while循环中使用：</p>
<p><code>break</code>关键字来提前终止循环, 只能终止它所在的那个循环,在嵌套的循环结构中使用， 不执行</p>
<p>continue： 放弃本次循环后续的代码直接让循环进入下一轮，继续执行</p>
<p>5, 格式化输出:<br>print(“zhangsan”,2)<br>print(“姓名:%s 年龄:%d” %(name,35)))<br>print(“{0}”.format(“你好))</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>o基础也能学会的人工智能笔记整理</title>
    <url>/article/2a662cad.html</url>
    <content><![CDATA[<p>1,机器学习<br>用大量数据进行训练，获取到 一个数据模型，预测就是应用训练的模型，来解决一个未知的问题</p>
<p>2,knn实现流程<br>收集相关的数据<br>选择合适的feature和label<br>如果不知道如何选择feature可以先单独每个feature计算与label的相关度<br>选取合适的k<br>使用数据集进行新的预测</p>
<p>3,分类和回归的区别(classification和regression)<br>回归是求topk的value求平均值<br>分类是求topk中出现最多的 类别</p>
<p>4,标准化和归一化的选择<br>知道数据范围用归一化<br>不知道数据范围,数据变化可能很大,用标准化</p>
<p>5,数据归一化<br>压缩样本数据到0~1之间,让向量之间的欧式距离变为标准欧式距离</p>
<p>6,线性回归和knn的区别<br>knn必须需要有全套数据集，每次预测都要重新计算整套数据集<br>线性回归，数据集用完后，其实可以丢弃。 线性回归是算一个<br>模型。<br>knn可以理解成是数学统计学的方法研究问题<br>线性回归，是一种总结规律，总结模型的解决问题的方法。</p>
<p>7,线性回归就是求线性函数的参数的值的过程</p>
<p>8,梯度下降算法原理<br>随机选取m和b<br>分别对mse 求m和b的偏导<br>如果m和b的偏导都很小(接近0),就成功<br>根据学习速率计算出修改的值<br>b和m 分别减去要修改的值</p>
<p>9,线性回归和逻辑回归的区别<br>线性回归:预测的数据是连续的<br>逻辑回归:预测的是分类的问题</p>
<p>10,人脸识别操作<br>安装百度api<br>pip install -U baidu-api</p>
<p>11,knn算法<br>调参:k<br>k一般取值总个数开平方<br>训练集的数据训练k.训练出的结果用测试集测试准确率</p>
<p>机器学习开发流程<br>1)获取数据<br>2)数据处理<br>3)特征工程<br>4)机器学习算法训练 - 模型<br>5)模型评估<br>6)应用</p>
<p>1,feature:变量  —- label:结果<br>变量和结果一一对应<br>2,np.array():表示数组<br>3,abs:绝对值<br>4,predicePoint:预测点—&gt;针对knn:k近邻<br>5,np.argsort():返回元素排序的下标位置<br>np.argsort(针对索引排序)<br>label —&gt; sortlabel<br>6,<br>np.sum:+<br>np.squart:平方<br>np.sqrt:开平方跟<br>np.loadtxt:读取文件:<br>属性<br>delimiter &#x3D; “,” :分隔符”,”<br>skiprows &#x3D; 1    :空除第一行<br>usecols &#x3D; (17,13,2):使用第17,13,2列<br>np.mean:平均值<br>np.stu:标准差<br>#显示完整的所有数据<br>np.set_printoptions(threshold&#x3D;np.inf)</p>
]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm插件整理</title>
    <url>/article/fb4b156c.html</url>
    <content><![CDATA[<p>1, Chinese: 汉化<br>2, translation: 翻译<br>3, Rainbow Brackets: 括号高亮<br>4, json parser: json格式的数据显示<br>5, markdown image support: markdown文档编辑器<br>6, Aixcoder code complate: 自动补全<br>7,CSV plugin<br>8,wakatime<br>9, .ignore<br>10, Context Free Grammar<br>11, SonarLint<br>12, Key Promoter X<br>13, Indent Rainbow<br>14, CodeGlance</p>
]]></content>
      <categories>
        <category>pycharm</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>python面试题</title>
    <url>/article/bf330a1e.html</url>
    <content><![CDATA[<p>1, __new__和__init__的区别<br>①__new__负责进行对象的创建,__init__负责进行对象的初始化<br>②__new__是在实例创建之前被调用,用于创建实例,然后返回该实例对象,是个静态方法,__init__是当实例对象创建完成之后被调用,用于初始化一个类实例,是个实例方法<br>③__new__至少有一个参数cls,必须要有返回值,返回的是实例化出来的实例,__init__在__new__基础上完成一些其他初始化的动作,__init__不需要有返回值</p>
<p>2,面向对象?<br>简称oop,把对象当做一个程序的基本单元,一个对象包含数据和操作数据的函数,提高了编程的效率,使其编程的重用性增高.<br>三大特点:<br>封装:把需要重用的函数或功能封装起来,方便其他程序直接调用,<br>继承 :子类继承父类,子类和父类拥有相同的方法和属性,子类会覆盖父类的方法和属性<br>多态:提高函数的健壮性和可扩展性,父类声明指向子类实现<br>多态的实现方式：<br>①对象多态: 在继承体系中,定义时的类型和运行时的类型不一样,此时构成多态<br>②类多态 : 只通过@classmethod形式多态构成的构造对象,而不是使用python默认的__init__构造器  </p>
<p>3,如何提高Python的运行效率?<br>①使用生成器,节省大量内存<br>②针对循环优化,避免过多重复代码的执行<br>③多个if else条件判断,可以把最有可能发生的条件放最前面写,减少程序判断次数,提高效率</p>
<p>4,描述数据,链表,队列,堆栈的区别?<br>答:数组和链表是数据存储方式的概念,数组在连续的自然空间中存储,链表在非连续的自然空间中存储<br>队列和堆栈是描述数据存储方式的概念,<br>队列是先进先出,堆栈是后进先出,堆栈和队列可以用数组表示,也可以用链表表示,<br>堆和栈<br>内存:<br>栈:内存小,速度快,有序,简单的数据类型放到栈里<br>堆:内存大,速度慢,无序,复杂的数据类型放到堆里</p>
<p>5,*args和**kw区别?<br>*args和**kw属于不定长参数<br>*args返回值为元组类型,**kw返回值为字典类型</p>
<p>6,&#x3D;和&#x3D;&#x3D;的区别?<br>&#x3D;:表示赋值.将某一数值赋值 给变量<br>&#x3D;&#x3D;:表示判断是否相等,返回True或者False,相等True,不相等False</p>
<p>9, next()和iter()的区别?<br>我们一般通过iter()函数获取可迭代对象的迭代器,通过对获取到的迭代器不断的通过next函数 进行获取下一条数据,iter()函数 实际上就是调用了可迭代对象的__iter__方法</p>
<p>10, 斐波那契数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入斐波那契数列的个数:&quot;</span>))</span><br><span class="line">fibs = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(item - <span class="number">1</span>):</span><br><span class="line">    fibs.append(fibs[-<span class="number">2</span>] + fibs[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;斐波那契数列为:&quot;</span>,fibsp[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>11,冒泡排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubblesort</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lsit)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">list</span>[j]&gt;<span class="built_in">list</span>[j+<span class="number">1</span>]:</span><br><span class="line">                <span class="built_in">list</span>[j],<span class="built_in">list</span>[j+<span class="number">1</span>] = <span class="built_in">list</span>[j+<span class="number">1</span>],<span class="built_in">list</span>[j]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#用户输入</span></span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入数字(用逗号隔开)&quot;</span>)</span><br><span class="line">    <span class="built_in">list</span> = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">    <span class="built_in">print</span>(bubblesort(<span class="built_in">list</span>))</span><br></pre></td></tr></table></figure>

<p>12, 类方法,静态方法,实例方法的区别<br>实例方法主要用于在类中封装一个额外的功能<br>第一个参数必须是self,一般情况下只能用实例化对象调用,不能用类调用,如果要用类调用,需要将实例化对象传递给self.<br>静态方法,主要用于在类中封装一个额外的功能,创建时用@staticmethod装饰器装饰,声明为静态函数,可以用类调用也可以用实例化对象调用<br>类方法主要是将类作为参数传递,相当于将类当成了对象,可以调用该类中的所有方法,创建时用@classmethod装饰器装饰,声明为类函数,第一个参数必须是cls,可以用类调用也可以用实例化对象调用.</p>
<p>代码展示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,title1</span>):</span></span><br><span class="line">        self.title = title1</span><br><span class="line">        <span class="built_in">print</span>(self.title)</span><br><span class="line">    <span class="comment">#实例函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self,title2</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(title2)</span><br><span class="line">   <span class="comment">#静态函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">static_foo</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;静态方法&quot;</span>)</span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cls_foo</span>(<span class="params">cls</span>):</span></span><br><span class="line">        cls.foo(a,<span class="string">&#x27;类函数调用实例函数&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类方法&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>13, collections库中的counter统计元素个数，</p>
<p>14，列表合并<br>a.extend(b)</p>
<p>15,字典合并<br>dic1.update(dic2)<br>删除 字典<br>del dic[‘sex’]<br>del:按索引删除元素<br>remove:默认删除第一个元素<br>pop:默认删除最后一个元素或者根据索引值删除索引</p>
<p>16,set集合去重的原理<br>set集合去重主要是通过函数__hash__和__eq__结合实现的<br>①当两个变量的哈希值不相同时,就认为两个变量时不相同的<br>②当两个变量哈希值一样时,调用__eq__方法,当返回值为True时认为两个变量时同一个,应该去除一个,返回FALSE时,不去重</p>
<p>18,列表切片属于浅拷贝</p>
<p>19, 深拷贝浅拷贝<br>深拷贝: 外围和内部元素都拷贝了对象本身,而不是引用,也就是说把对象复制一遍,对象中引用的其他对象也复制.<br>浅拷贝: 拷贝了最外围对象本身, 内部元素只拷贝了一个引用, 也就是说把对象复制一遍,对象中引用的其他对象不复制.</p>
<p>21, python垃圾回收机制<br>在python内部, 当一个对象的引用计数是0时, 它将被垃圾回收机制处理掉<br>当两个对象a和b相互引用时的情况,del语句可以减少a和b的引用计数,并销毁用于底层对象的名称,需要注意的是,并不是每一个对象都包含一个对其他对象的应用,所以这种情况下引用计数不会归0, 对象也不会被销毁,这就是可能会导致内存泄露,所以为了解决这个问题,解释器会定期执行一个循环检测器,搜素不可访问对象的循环并进行删除.</p>
<p>22, 线程与进程,协程<br>进程: 是程序执行的一次过程,是临时的,有生命周期的, 任何进程都可以同其他进程一起并发执行,是系统进行资源分配和调度的一个独立单位,由程序,数据和进程控制块三部分组成<br>进程池:当存在多个进程时,为避免资源损耗,创建适当的进程放入进程池,等待待处理的事件,当处理完所有事件之后,进程退出<br>线程: 线程是程序执行中一个单一的顺序控制流程,是程序执行的最小单元,一个进程可以有一个或多个线程,</p>
<p>死锁: 在线程间共享多个资源时,两个线程分别占用资源并且同时等待对方的资源,就会造成死锁,<br>协程: 执行函数A时可以随时中断执行函数B,然后中断函数B继续执行函数A,协程是一个线程在执行.</p>
<p>GIL锁:<br>全局解释器锁,同一进程加入有多个线程运行,一个线程在运行python程序时会霸占python解释器,也就增加了一把锁,使该进程中的其他线程无法运行,等该线程运行完成后其他线程才能运行,</p>
<p>23, 可变数据类型,不可变数据类型(为什么不可变,为什么可变)<br>可变: 列表,字典,<br>原因: 如果对对象进行了添加,修改等操作之后, 只是改变了变量的值,而不会新建一个对象, 变量引用的对象地址也不会发生变化,不过对于相同值的对象,即每个对象都有自己的地址,<br>不可变: 整型,字符串,布尔型,元组,<br>原因: 如果变量值发生了变化,相当于新建一个对象,而对于相同值的对象,在内存中只有一个地址,</p>
<p>24,  装饰器,闭包,迭代器,生成器<br>闭包: 外函数包含内函数, 对函数功能进行扩展,一般在装饰器下写闭包<br>装饰器: 为已经存在的对象添加额外的功能,在不改变原代码的情况下,扩展额外功能.(在什么情况下使用)<br>eg: 定义验证登录状态的装饰器<br>判断用户是否登录,如果登录,执行视图函数,如果未登录,返回未登录信息,然后在退出以及需要验证登录的模块调用装饰器<br>迭代器: for循环遍历取值的过程<br>生成器: yield关键字来返回值的函数</p>
<p>  生成器(generator)的定义与普通函数类似，生成器使用yield关键字生成值。<br>  如果一个函数包含yield关键字，那么该函数将自动成为一个生成器。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">装饰器</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>

<p>25, celery<br>主要是用于处理耗时任务，包含的三个模块<br>  1, broker： 存储生产者发出的各种任务 （将任务添加到broker）,存储执行结果,<br>     2. worker： 实时监控消息队列，如果有任务就获取任务并执行它 （worker服务）<br>     3. task: 定义任务函数 （任务函数）,将任务添加到broker,判断任务是否执行完成.</p>
<p>26, Python如何处理高并发？<br>1.HTML页面静态化<br>2.图片服务器分离（可以用fastdfs轻量级的分布式文件存储系统）<br>3.使用缓存（用redis）<br>4.数据库集群、读写分离。减轻数据库服务器的读写压力。<br>5.使用负载均衡的方法（配置nigix服务器，用nginx来配置负载均衡，只需要设置 如下代码，即可实现简单的负载均衡)<br>应用场景</p>
<p>27, python的单例模式和工厂模式<br>单例模式:对__new__方式进行重写,确保一个类只有一个实例,并且提供一个访问该实例的全局访问点,<br>单例模式只生成一个实例对象,减少对系统资源的开销,当一个对象产生比较多的资源,如读取配置文件,产生其他依赖对象时,可以产生一个”单例对象”,然后永久驻留内存中,从而极大的降低开销.<br>工厂模式:实现了创建者和调用者的分离,使用专门的工厂类将选择实现类,创建对象进行统一的管理和控制.</p>
<p>28， python的异常类型<br> ① ZeroDivisionError 除(或取模)零(所有数据类型)<br> ② IndexError #序列中没有此索引<br> ③ KeyError #映射中没有这个键<br> ④ NameError #未声明&#x2F;初始化对象 (没有属性)<br> ⑤ SyntaxError #python语法错误<br> ⑥ ValueError #传入无效的参数</p>
<p>29， json和字典的相互转换<br>json转字典： json.loads()<br>字典转json: json.jumps</p>
<p>30，finally关键字的作用<br>try:<br>    正确语句<br>except:<br>    错误信息提示<br>finally:<br>    最后执行的模块</p>
<p>31, numpy,  pandas,<br>np: 数组处理,矩阵运算<br>pd: 对csv&#x2F;txt文件进行读取写入操作, 对json, 数据库, excel进行读取写操作</p>
<p>33,  正则表达式:<br>re.search(),res.match()匹配一次<br> match和search的区别<br> match()只会检测re是不是在string的开始位置匹配<br> search()会扫描整个string查找匹配<br> match()只有在0位置匹配成功的话才有返回, 如果不是开始位置匹配成功的话,match就返回none.<br>re.findall(): 匹配所有<br>re.sub()替换<br>re.split()分割<br>. 任意字符</p>
<ul>
<li>零个或多个<br>? 匹配零个或一个由前面的正则表达式定义的片段,<br>贪婪模式和非贪婪模式<br>在满足匹配时,匹配尽可能长的字符串,默认情况下,采用贪婪模式<br>匹配到结果就好,少的匹配字符,就是非贪婪模式</li>
</ul>
<p>34, Python中的self是什么？<br>self是类的实例或对象。在Python中，self包含在第一个参数中。但是，Java中的情况并非如此，它是可选的。它有助于区分具有局部变量的类的方法和属性。init方法中的self变量引用新创建的对象，而在其他方法中，它引用其方法被调用的对象。</p>
<p>35, Python数组和列表有什么区别？<br>python本身并没有数组类型，但Numpy库中有数组类型。<br>Python中的数组和列表具有相同的存储数据方式。<br>数组里面元素的数据类型必须是相同的，而列表可以包含任何数据类型元素。</p>
<p>36, classmethod, staticmethod,property<br>classmethod，staticmethod，property都是装饰器， 他们都作用在类的方法上。<br>classmethod：使得被装饰的方法成为一个类方法既不需要实例化类就可以直接调用的方法，第一个参数为cls。<br>staticmethod： 使得被装饰的方法成为一个静态函数既与普通的函数无区别。<br>property: 将一个方法变成一个属性来使用。</p>
<p>37, python如何进行内存管理<br> Python内存由Python的私有headspace管理。<br> 所有的Python对象和数据结构都位于一个私有堆中。私用堆的分配由Python内存管理器负责。<br> Python还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于headspace。</p>
<p>38, python2和python3的区别<br>①. 整数,python2中区分整型int和长整型long,python3不区分<br>②.python3中 True和False都是关键字,python2里面不是<br>③.python2中的’&#x2F;‘整数相除得到的是整数,python3中的’&#x2F;‘相除获得的是真除.<br>④.python2中print打印不一定要求函数形式使用,python3的print是强制函数<br>⑤. python2中的xrange相当于python3中的range,python3中没有xrange.<br>⑥.python2中的input默认是int型,python3中的input默认是str型</p>
<p>39,python常见库<br>sys、math、random、data time、JSON。</p>
<p>40, Python中append，insert和extend的区别?<br>  append：在列表末尾添加新元素。<br>  insert：在列表的特定位置添加元素。<br>  extend：通过添加新列表来扩展列表。 </p>
<p>41, break、continue、pass是什么？<br>  break：在满足条件时，它将导致程序退出循环。<br>  continue：将返回到循环的开头，它使程序在当前循环迭代中的跳过所有剩余语句。<br>  pass：使程序传递所有剩余语句而不执行。 </p>
<p>42, 如何使用索引来反转Python中的字符串<br>string[::-1]</p>
<p>43, 什么是负指数，功能是什么？<br>Python中的序列是索引的，它由正数和负数组成。积极的数字使用’0’作为第一个索引，’1’作为第二个索引，进程继续使用。<br>负数的索引从’-1’开始，表示序列中的最后一个索引，’ - 2’作为倒数第二个索引，序列像正数一样前进。<br>负索引用于从字符串中删除任何换行符，并允许该字符串除了作为S [： - 1]给出的最后一个字符。负索引还用于显示索引以正确的顺序表示字符串。</p>
<p>43、什么是Python包？<br>Python包是包含多个模块的命名空间。</p>
<p>44, capitalize()函数可以将字符串的第一个字母大写</p>
<p>45, range返回一个Python列表对象，xrange返回一个xrange对象</p>
<p>46, python内存池机制<br>当创建大量消耗小内存的对象时，频繁调用new&#x2F;malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。</p>
<p>9,悲观锁,乐观锁</p>
<p>乐观锁: 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改</p>
<p>悲观锁: 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>svn使用</title>
    <url>/article/df8f2d0d.html</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1WGIjMTBU_7J9BLoiBHbSjw">软件地址</a></p>
<p>提取码: 4iuo</p>
<p><a href="https://pan.baidu.com/s/1eWpX4ai5_eTaLHCn0x1_hQ">汉化包地址</a></p>
<p>提取码: 7u70 </p>
<p>汉化说明:</p>
<p>在任意位置右击—&gt;TortoiseSVN—&gt;settings—&gt;General—&gt;Language(简体中文)—&gt;应用 —&gt; 确定</p>
<p>1, 导出项目</p>
<p>在检出目录文件夹下:</p>
<p>右击—&gt;SVN检出—&gt;填写版本库url—&gt;确定</p>
<p>**版本库url为服务器地址,检出标志为绿色的√</p>
<p>2, 修改文件,添加文件,删除文件</p>
<pre><code>2.1 添加文件

    选中 ---&gt; 右击 ---&gt; 加入 (会出现蓝色感叹号) --- &gt; 提交
</code></pre>
<p>总结: add ,commit</p>
<pre><code>2.2 修改文件

    检出要修改的文件 ---&gt; 右击 ---&gt; SVN更新 (对文件内容进行修改,保存,&#39;会出现红色感叹号&#39;) ---&gt; 提交(对提交文件进行相关备注)
</code></pre>
<p>格式:</p>
<pre><code>*XXXX年—XX月—XX日 姓名 修改内容：XXXXXXXX 修改原因：YYYYYYYYYYYYY\*

2.3 重命名文件

    选中文件---&gt;SVN更新---&gt;修改文件名---&gt;add---&gt;commit

2.4删除文件(删除前备份)

    选中文件---&gt; SVN更新 ---&gt; 删除 ---&gt; 提交
</code></pre>
<p>总结:</p>
<pre><code>更新,提交,显示日志,改名,删除
</code></pre>
<p>checkout:将文件添加到本地目录</p>
<p>add: 往版本库添加新的文件</p>
<p>commit: 将改动的文件提交到版本库</p>
<p>lock&#x2F;unlock: 加锁&#x2F;解锁</p>
<p>update: 更新</p>
<p>delete: 删除</p>
]]></content>
      <categories>
        <category>svn</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>python面试题1.md</title>
    <url>/article/56c4f7dd.html</url>
    <content><![CDATA[<p>1, 线程，进程，协程</p>
<p>线程：程序执行中一个单一的顺序控制流程，是程序执行的最小单元，一个进程可以有一个或多个线程。</p>
<p>进程：是程序执行的一次过程，是临时的，有生命周期的。任何进程都可以同其他进程一起并发执行，是系统进行资源分配，调度的一个独立单位，由程序，数据和进程控制块三部分组成。</p>
<p>协程：在执行函数 A 时可以随时中断去执行函数B，然后中断函数 B继续执行函数 A,协程是一个线程在执行。</p>
<p>2，GIL 锁</p>
<p>全局解释器锁，同一进程加入有多个线程运行，一个线程在运行python程序时会霸占python 解释器，也就增加了一把锁。使该进程中的其他线程无法运行，等该线程运行完成之后其他线程才能运行。</p>
<p>3，多进程，多线程，进程池，线程池</p>
<p>多进程：python 提供了multiprocessing模块来支持多进程编程。</p>
<p>可以通过Process类来创建进程，并使用Queue、Pipe等数据结构来实现进程间通信。同时，Python中还有一些其他的并行编程库，如concurrent.futures和joblib，它们也提供了更方便的接口来实现并行计算。</p>
<p>进程池：创建适当的进程放入进程池,等待待处理事件,当处理完事件后进程不会销毁,仍然在进程池中等待处理其他事件,直到事件全部处理完毕.进程退出。</p>
<p>多线程：python 提供 threading 模块来支持多线程编程。</p>
<p>线程池: python的concurrent.futures模块提供了线程池和进程池的支持,可以用于并发处理I&#x2F;O操作.</p>
<p>4，线程安全</p>
<p>线程安全是指在多线程环境中，多个线程同时访问共享资源时，保证程序的行为和结果是预期的。线程安全的代码能够避免竞态条件，死锁等并发问题，确保数据的一致性和正确性。</p>
<p>实现方式：</p>
<p>1,锁机制：使用锁（互斥锁，读写锁）来保护共享资源，确保同一时间只有一个线程可以访问该资源。</p>
<p>2.线程本地存储：每个线程都有自己独立的存储空间，避免共享资源的竞争。</p>
<p>5，线程锁</p>
<p>多个线程共享公共资源时,由于使用了线程锁,每个线程在修改共享资源时都会先获取锁,确保只有一个线程对公共资源进行处理,避免多个线程同时修改共享资源而导致的竞态条件问题.</p>
<p>6，死锁</p>
<p>即某个线程获取锁后无法释放锁,导致其他线程无法继续执行.死锁的解决方法:①添加超时时间②银行家算法(让锁按预期上锁和解锁)</p>
<p>7, 异步</p>
<p>asyncio， 通过使用async&#x2F;await语法和事件循环来实现非阻塞的并发任务</p>
<p>使用asyncio库的协程特性来实现高效的并发编程，通过协程的方式可以避免线程切换的开销。</p>
<p>8，pandas</p>
<p>pandas 主要用于</p>
<p>​    1，数据读取，数据保存，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#pd.read<span class="constructor">_csv()</span>, pd.read<span class="constructor">_excel()</span>, pd.read<span class="constructor">_json()</span></span><br><span class="line">#df.<span class="keyword">to</span><span class="constructor">_csv()</span>, df.<span class="keyword">to</span><span class="constructor">_excel()</span>, df.<span class="keyword">to</span><span class="constructor">_json()</span></span><br><span class="line"># 读取 CSV 文件</span><br><span class="line">df = pd.read<span class="constructor">_csv(&#x27;<span class="params">data</span>.<span class="params">csv</span>&#x27;)</span></span><br><span class="line"></span><br><span class="line"># 保存为 Excel 文件</span><br><span class="line">df.<span class="keyword">to</span><span class="constructor">_excel(&#x27;<span class="params">output</span>.<span class="params">xlsx</span>&#x27;, <span class="params">index</span>=False)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    2，数据过滤，选择</p>
<p>​    •    <strong>按列选择</strong>：df[‘ColumnName’] 或 df.ColumnName</p>
<p>​    •    <strong>按行选择</strong>：</p>
<p>​            •    <strong>标签索引</strong>：df.loc[]，基于行标签。</p>
<p>​            •    <strong>位置索引</strong>：df.iloc[]，基于行位置。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择单列</span></span><br><span class="line"><span class="attr">ages</span> = df[<span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择多列</span></span><br><span class="line"><span class="attr">subset</span> = df[[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件过滤</span></span><br><span class="line"><span class="attr">adults</span> = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt;= <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 loc 按标签选择</span></span><br><span class="line"><span class="attr">row</span> = df.loc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iloc 按位置选择</span></span><br><span class="line"><span class="attr">row</span> = df.iloc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>​    3，数据清洗与处理</p>
<p>​        •    <strong>处理缺失值</strong>：</p>
<p>​            •    检测缺失值：df.isnull()</p>
<p>​            •    删除缺失值：df.dropna()</p>
<p>​            •    填充缺失值：df.fillna(value)</p>
<p>​        •    <strong>数据类型转换</strong>：df[‘ColumnName’] &#x3D; df[‘ColumnName’].astype(new_type)</p>
<p>​        •    <strong>重命名列</strong>：df.rename(columns&#x3D;{‘OldName’: ‘NewName’})</p>
<p>   4， 数据排序</p>
<p>​    •    <strong>按值排序</strong>：df.sort_values(by&#x3D;’ColumnName’, ascending&#x3D;True)</p>
<p>​    •    <strong>按索引排序</strong>：df.sort_index()</p>
<p>  5，数据添加与删除 </p>
<p>​    •    <strong>添加列</strong>：df[‘NewColumn’] &#x3D; values</p>
<p>​    •    <strong>删除列</strong>：df.drop(‘ColumnName’, axis&#x3D;1)</p>
<p>​    •    <strong>添加行</strong>：df.append(new_row, ignore_index&#x3D;True)</p>
<p>​    •    <strong>删除行</strong>：df.drop(index)</p>
<p>  6， 数据分组与聚合</p>
<p>​    •    <strong>分组操作</strong>：df.groupby(‘ColumnName’)</p>
<p>​    •    <strong>聚合函数</strong>：sum(), mean(), count(), max(), min()</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># 按性别分组，计算平均年龄</span><br><span class="line"><span class="selector-tag">df</span><span class="selector-class">.groupby</span>(<span class="string">&#x27;Gender&#x27;</span>)<span class="selector-attr">[<span class="string">&#x27;Age&#x27;</span>]</span><span class="selector-class">.mean</span>()</span><br></pre></td></tr></table></figure>

<p>​    7，合并与连接</p>
<p>​            •    <strong>合并数据集</strong>：pd.merge(df1, df2, on&#x3D;’Key’)</p>
<p>​            •    <strong>连接数据集</strong>：pd.concat([df1, df2], axis&#x3D;0)（行合并），axis&#x3D;1（列合并）</p>
<p>​            •    <strong>加入操作</strong>：df1.join(df2, on&#x3D;’Key’)</p>
<p>   8，数据透视表</p>
<p>​            •    <strong>创建透视表</strong>：pd.pivot_table(df, values&#x3D;’ValueColumn’, index&#x3D;’IndexColumn’, columns&#x3D;’ColumnsColumn’,                             aggfunc&#x3D;’mean’)</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按性别和部门计算平均薪资</span></span><br><span class="line">pd.pivot_table(df, <span class="attribute">values</span>=<span class="string">&#x27;Salary&#x27;</span>, <span class="attribute">index</span>=<span class="string">&#x27;Department&#x27;</span>, <span class="attribute">columns</span>=<span class="string">&#x27;Gender&#x27;</span>, <span class="attribute">aggfunc</span>=<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>   9，应用函数</p>
<p>​    •    <strong>逐元素操作</strong>：df[‘ColumnName’].apply(func)</p>
<p>​    •    <strong>整列或整行操作</strong>：df.apply(func, axis&#x3D;0)（列），axis&#x3D;1（行）</p>
<p>​    •    <strong>映射操作</strong>：df[‘ColumnName’].map(mapping_dict)</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"># 计算年龄的平方</span><br><span class="line">df[<span class="string">&#x27;Age_Squared&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(lambda x: x ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"># 将性别映射为数字</span><br><span class="line">gender_map = &#123;<span class="string">&#x27;Male&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Female&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line">df[<span class="string">&#x27;Gender_Num&#x27;</span>] = df[<span class="string">&#x27;Gender&#x27;</span>].map(gender_map)</span><br></pre></td></tr></table></figure>

<p>​    10，时间与日期处理</p>
<p>​    •    <strong>解析日期</strong>：pd.to_datetime(df[‘DateColumn’])</p>
<p>​    •    <strong>提取日期属性</strong>：df[‘DateColumn’].dt.year, df[‘DateColumn’].dt.month</p>
<p>​    •    <strong>日期差计算</strong>：df[‘EndDate’] - df[‘StartDate’]</p>
<p>​     11，数据去重</p>
<p>​        •    <strong>检测重复</strong>：df.duplicated()</p>
<p>​        •    <strong>删除重复</strong>：df.drop_duplicates()</p>
<p>​     12，窗口函数</p>
<p>​        •    <strong>滚动计算</strong>：df[‘ColumnName’].rolling(window_size).mean()</p>
<p>​        •    <strong>累积计算</strong>：df[‘ColumnName’].expanding().sum()</p>
<p>​      13， 性能优化</p>
<p>​        •    <strong>设置合适的数据类型</strong>：使用 astype() 将数据转换为更节省内存的类型。</p>
<p>​        •    <strong>使用矢量化操作</strong>：避免使用循环，多利用 pandas 内置函数。</p>
<p>​        •    <strong>使用</strong> categorical <strong>类型</strong>：对于重复值多的字符串列，转换为分类类型可节省内存。</p>
<p>​     14，列表去重</p>
<p>​            unique_lis1 &#x3D; pd.unique(lis1).tolist() </p>
<p>9，nosql, hadoop, spark</p>
<p>处理海量数据,关键在于海量存储和快速查询,技术选型包含分布式数据库,NoSQL数据库,内存数据库和大数据处理框架(eg:Hadoop, Spark). 关键技术和策略包括数据分片(Sharding),索引优化,数据压缩,缓存机制和并行处理,使用合适的数据结构和算法来减少资源消耗.</p>
<p>10，数仓，宽表</p>
<p>宽表： 指业务主题相关的指标，维度，属性关联在一起的一张数据库表。将多个数据源的数据整合到一张表当中。eg:用户信息，订单信息，行为日志表等数据可以整合到一张宽表。</p>
<p>数仓：数据仓库，是一个面向主题的，集成的，非易失性的，随时间变化的数据集合。数仓存储来着多源系统的数据，并经过清洗，转换和集成，支持复杂查询和分析。</p>
<p>数仓通常采用星型或雪花模型来设计数据模型，包括事实表和维度表。</p>
<p>事实表：存储业务中的度量数据（eg：销售额，订单数）</p>
<p>维度表：存储描述业务实体的属性数据（eg:时间，地点，产品）</p>
<p>宽表: 适用于快速数据查询和分析、报表生成和机器学习模型的输入。通过整合多个相关数据源，创建一个包含丰富信息的单表。</p>
<p>数据仓库: 适用于支持企业的决策系统，进行复杂查询和分析。通过主题化、集成化的数据存储，提供统一的视图，支持长时间跨度的历史数据分析。</p>
<p>11，nosql</p>
<p>数据类型：面向文档，健值，图表，列导向</p>
<p>数据库水平和垂直缩放的区别</p>
<p>水平扩展意味着您通过将更多机器添加到资源池中来进行扩展，(mongodb)</p>
<p>垂直缩放意味着您通过向现有机器添加更多功率（CPU,RAM）来进行缩放,(mysql-Amzon RDS)</p>
<p>12，hadoop 和 Spark 区别。</p>
<p>hadoop:主要是存储和批处理大规模数据。</p>
<p>spark: 主要用于高效的实时处理，迭代计算或交互式查询。</p>
<p>13, hadoop组件</p>
<p>1）HDFS集群：负责海量数据存储，集群中的主要角色NameNode&#x2F;DataNode</p>
<p>2）YARN集群：负责海量数据运算时的资源调度,集群中的ResourceMamager&#x2F;NodeManager</p>
<p>3）MapReduce: 它其实是一个应用程序开发包</p>
<p>14，</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ros系统学习笔记</title>
    <url>/article/3e9342ec.html</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1qV41167d2?p=1">视频链接</a></p>
<p>环境安装说明:</p>
<p> 安装链接:</p>
<pre><code>  [ROS安装](https://www.guyuehome.com/33971)
</code></pre>
<p>类似错误修复链接:</p>
<pre><code>[大部分错误针对修改有效](https://blog.csdn.net/qq_44830040/article/details/106049992)
</code></pre>
<p>安装步骤:</p>
<p>1,配置Ubuntu系统<br>打开软件中心,允许以下三种软件源<br>①restricted（不完全的自由软件）<br>②universe（Ubuntu官方不提供支持与补丁，全靠社区支持）<br>③multiverse（非自由软件，完全不提供支持和补丁）这三种软件源<br>下载地址:Download from为阿里云<br><a href="http://mirrors.aliyun.com/ubuntu">http://mirrors.aliyun.com/ubuntu</a></p>
<p>2,打开终端,添加软件源<br>sudo sh -c ‘echo “deb <a href="http://packages.ros.org/ros/ubuntu">http://packages.ros.org/ros/ubuntu</a> $(lsb_release -sc) main” &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;ros-latest.list’</p>
<pre><code>2.1

        使用国内的镜像源,提高下载速度:(以下任意一个)

             sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;

             sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirror.sysu.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;

            sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://ros.exbot.net/rospackage/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;
</code></pre>
<p>3,添加密钥(以下任意一个)<br>sudo apt-key adv ——keyserver hkp:&#x2F;&#x2F;ha.pool.sks-keyservers.net:80 ——recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</p>
<p>sudo apt-key adv –keyserver ‘hkp:&#x2F;&#x2F;keyserver.ubuntu.com:80’ –recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</p>
<p>4,更新添加的软件源<br>sudo apt-get update</p>
<p>5,下载ros版本<br>sudo apt-get install ros-kinetic-desktop-full</p>
<p>6,初始化<br>sudo rosdep init</p>
<p>7,更新(实在不行此命令执行5~6次后可以忽略,暂时无影响)<br>rosdep update</p>
<p>8,设置ros环境变量,路径为home下ctrl + h打开隐藏文件就可看到</p>
<p>echo “source &#x2F;opt&#x2F;ros&#x2F;kinetic&#x2F;setup.bash” &gt;&gt; ~&#x2F;.bashrc</p>
<p>source ~&#x2F;.bashrc</p>
<p>9,运行:roscore</p>
<p>三,测试是否安装成功<br><a href="https://blog.csdn.net/dd_Mr/article/details/114323752">链接地址</a></p>
<p>①在终端运行以下命令开启ros<br>roscore<br>②打开一个新终端运行以下命令打开小乌龟窗口<br>rosrun turtlesim turtlesim_node<br>③打开新终端运行以下命令通过键盘控制小乌龟运动<br>rosrun turtlesim turtle_teleop_key<br>④打开新终端运行以下命令,看到ros的图形化界面,展示节点的关系,若终端无报错说明安装成功<br>rosrun rqt_graph rqt_graph</p>
<p>四,Ubuntu16.04上安装kitti2bag<br><a href="https://blog.csdn.net/weixin_38636815/article/details/108376178">链接地址</a></p>
<p>①安装依赖包<br>sudo pip install pandas&#x3D;&#x3D;0.23.0 -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a> –trusted-host pypi.douban.com</p>
<p>sudo pip install pykitti -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p>
<p>sudo pip install kitti2bag  -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p>
<p>②安装kitti2bag包<br>sudo pip install kitti2bag</p>
<p>五,kitti2bag包对kitti数据集的处理<br><a href="https://pan.baidu.com/s/1dpGDeYXYHHKtjmfX1IsVZw">数据集链接:</a><br>密码:oqym</p>
<p>打开下载的数据集,在2011_09_26目录的上一层目录下执行指令：<br>kitti2bag -t 2011_09_26 -r 0005 raw_synced .</p>
<p>生成一个ros可执行包:kitti_2011_09_26_drive_0005_synced.bag</p>
<p>执行以下命令打开图像可视化软件:<br>rqt_bag kitti_2011_09_26_drive_0005_synced.bag</p>
<p>读取图片:在文件上右键 —&gt; View —&gt; Image:<br>点击播放按钮一帧一帧的读取图片,一共15秒</p>
<p>缺点:只能读取图片,不能进行点云的读取</p>
<p>六:通过程序对kitti数据集进行处理<br>1,建立目录catkin_ws&#x2F;src<br>2,在src目录下建包<br>catkin_create_pkg 包名(kitti_tutorial) rospy<br>3,进入包kitti_tutorial下建立资料夹:<br>catkin_make<br>4,在包下的src文件中编写程序,环境为python2,程序中无法写入中文,会报错,程序采用的是ASCII编码形式<br>5,程序完成后进入catkin_ws&#x2F;src目录下执行以下命令:<br>roscd 包名(kitti_tutorial)&#x2F;src</p>
<p>chmod +x 主程序(kitti.py)</p>
<p>rosrun 包名(kitti_tutorial) 主程序(kitti.py)</p>
<p>在新终端运行ros:<br>roscore</p>
<p>在新终端打开rviz:<br>rviz</p>
<p>在rviz中运行:<br>add —&gt; By topic(选择要运行的,例如图片,云点图,imu等)</p>
<p>保存:选择file—&gt;save config as —&gt; 文件名 </p>
]]></content>
      <tags>
        <tag>linix</tag>
        <tag>ros</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发1-nginx部署</title>
    <url>/article/3c1ae316.html</url>
    <content><![CDATA[<h6 id="方案-1：uwsgi-nginx部署"><a href="#方案-1：uwsgi-nginx部署" class="headerlink" title="方案 1：uwsgi+nginx部署"></a>方案 1：uwsgi+nginx部署</h6><p>uwsgi的安装: pip install uwsgi</p>
<p>创建配置文件: uwsgi.ini</p>
<p>uwsgi.ini 配置文件内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"><span class="comment"># uWSGI 监听的 UNIX Socket</span></span><br><span class="line">socket = uwsgi.sock</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目目录</span></span><br><span class="line">chdir=/Users/fanyong/Desktop/code/DjangoBlog</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目中wsgi.py文件的目录，相对于项目目录</span></span><br><span class="line">wsgi-file=djangoblog/wsgi.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程数</span></span><br><span class="line">processes=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#线程数</span></span><br><span class="line">threads=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启master进程</span></span><br><span class="line">master=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存放进程编号的文件</span></span><br><span class="line">pidfile=uwsgi.pid</span><br><span class="line"></span><br><span class="line"><span class="comment">#日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的</span></span><br><span class="line">daemonize=uwsgi.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定依赖的虚拟环境</span></span><br><span class="line">virtualenv=/Users/fanyong/mambaforge/envs/DjangoBlog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Socket 访问权限</span></span><br><span class="line">chmod-socket = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 uWSGI 在项目代码更新后自动重启</span></span><br><span class="line">touch-reload = djangoblog/wsgi.py</span><br></pre></td></tr></table></figure>

<p>uwsgi模块常用命令：</p>
<p>uwsgi启动: uwsgi –ini uwsgi.ini</p>
<p>uwsgi重启: uwsgi –reload uwsgi.pid</p>
<p>uwsgi停止: uwsgi –stop uwsgi.pid</p>
<p>服务器上nginx安装配置：</p>
<p>更新系统：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="meta">update</span> <span class="variable">&amp;&amp;</span> sudo apt upgrade -y</span><br></pre></td></tr></table></figure>

<p>安装依赖：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install python<span class="number">3</span>-pip python<span class="number">3</span>-venv nginx -y</span><br></pre></td></tr></table></figure>

<p>设置开机自启：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> gunicorn</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> gunicorn</span><br></pre></td></tr></table></figure>

<p>检查Gunicorn状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo systemctl status gunicorn</span></span><br></pre></td></tr></table></figure>

<p>配置nginx：</p>
<p>nginx配置文件路径介绍：</p>
<p>配置目录：&#x2F;etc&#x2F;nginx<br>执行文件: &#x2F;usr&#x2F;sbin&#x2F;nginx<br>日志目录：&#x2F;var&#x2F;log&#x2F;nginx<br>启动文件：&#x2F;etc&#x2F;init.d&#x2F;nginx<br>web目录：&#x2F;var&#x2F;www&#x2F;html&#x2F;，首页文件是index.nginx-debian.html</p>
<p>1，查看服务状态:     systemctl status nginx &#x2F; service nginx status</p>
<p>2，创建 nginx配置 文件</p>
<p>​    2.1, 生成私钥：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p <span class="regexp">/etc/</span>nginx/ssl</span><br><span class="line">cd <span class="regexp">/etc/</span>nginx/ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">sudo openssl genpkey -algorithm RSA -out nginx-selfsigned.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书请求（CSR）</span></span><br><span class="line">sudo openssl req -new -key nginx-selfsigned.key -out nginx-selfsigned.csr \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=MyCompany/OU=IT/CN=127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成自签名证书（有效期 365 天）</span></span><br><span class="line">sudo openssl x509 -req -days <span class="number">365</span> -<span class="keyword">in</span> nginx-selfsigned.csr -signkey nginx-selfsigned.key -out nginx-selfsigned.crt</span><br></pre></td></tr></table></figure>

<p>​    2.1.1, 更新nginx.conf</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ssl_certificate <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>nginx-selfsigned.crt;</span><br><span class="line">ssl_certificate_key <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>nginx-selfsigned.key;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>2.2, 在 nginx.conf 文件当中追加</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追加内容</span></span><br><span class="line">include <span class="regexp">/opt/</span>homebrew<span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d/</span>*.conf;</span><br></pre></td></tr></table></figure>

<p>​    2.3, 在指定目录下创建对应的配置文件（eg:djangoblog.conf）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name <span class="number">127.0</span>.<span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    ssl_certificate <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>nginx-selfsigned.crt;</span><br><span class="line">    ssl_certificate_key <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>nginx-selfsigned.key;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    root <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code/DjangoBlog;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/static/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/</span>collectedstatic/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/media/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/u</span>ploads/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass unix:<span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/u</span>wsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name <span class="number">127.0</span>.<span class="number">0.1</span>;</span><br><span class="line">    return <span class="number">301</span> https:<span class="regexp">//</span><span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检查配置文件是否有问题:     nginx -t<br>重新加载配置文件:     nginx -s reload</p>
<p>访问项目！</p>
<h6 id="方案-2-gunicorn-nginx"><a href="#方案-2-gunicorn-nginx" class="headerlink" title="方案 2: gunicorn+nginx"></a>方案 2: gunicorn+nginx</h6><p>创建<strong>Gunicorn systemd 服务</strong>并完成开机自启：vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;gunicorn.service</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换your_user和myproject</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Gunicorn daemon for Django project</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=your_user</span><br><span class="line"><span class="attr">Group</span>=www-data</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/var/www/myproject</span><br><span class="line"><span class="attr">ExecStart</span>=/var/www/myproject/venv/bin/gunicorn --workers <span class="number">3</span> --bind unix:/var/www/myproject/gunicorn.sock myproject.wsgi:application</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>设置开机自启：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> gunicorn</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> gunicorn</span><br></pre></td></tr></table></figure>

<p>检查Gunicorn状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo systemctl status gunicorn</span></span><br></pre></td></tr></table></figure>

<p>静态资源文件的处理</p>
<p> 在settings.py中配置静态资源文件路径：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">STATIC_ROOT</span> = <span class="string">&quot;/var/www/myproject/static/&quot;</span></span><br></pre></td></tr></table></figure>

<p>静态资源文件的生成：python manage.py collectstatic –noinput</p>
<p>gunicorn 启动：gunicorn –workers 3 –bind unix:&#x2F;tmp&#x2F;gunicorn.sock djangoblog.wsgi</p>
<p>以守护进程的方式启动：gunicorn –workers 3 –bind unix:&#x2F;tmp&#x2F;gunicorn.sock djangoblog.wsgi –daemon</p>
<p>nginx配置文件:<br>&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/nginx-selfsigned.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/nginx-selfsigned.key;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment"># dev</span></span><br><span class="line">        proxy_pass http://unix:/tmp/gunicorn.sock;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static/ &#123;</span><br><span class="line">		alias /Users/fanyong/Desktop/code/DjangoBlog/collectedstatic/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /media/ &#123;</span><br><span class="line">        alias /Users/fanyong/Desktop/code/DjangoBlog/uploads/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>检查配置文件是否有问题:     nginx -t<br>重新加载配置文件:     nginx -s reload</p>
<p>访问项目！</p>
<p>补充说明，以下和在nginx中配置为两个方法，以下开发中使用。</p>
<p>ssl: uwsgi免费获取SSL证书方法如下：</p>
<p>1，执行如下命令</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo apt install certbot python3-certbot-nginx -y</span><br><span class="line">sudo certbot <span class="comment">--nginx -d your_domain</span></span><br></pre></td></tr></table></figure>

<p>自动续订：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo certbot renew <span class="comment">--dry-run</span></span><br></pre></td></tr></table></figure>



<p>2，nginx 配置</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name <span class="number">127.0</span>.<span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    ssl_certificate <span class="regexp">/etc/</span>letsencrypt<span class="regexp">/live/y</span>our_domain/fullchain.pem;</span><br><span class="line">    ssl_certificate_key <span class="regexp">/etc/</span>letsencrypt<span class="regexp">/live/y</span>our_domain/privkey.pem;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    root <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code/DjangoBlog;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/static/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/</span>collectedstatic/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/media/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/u</span>ploads/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass unix:<span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/u</span>wsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name <span class="number">127.0</span>.<span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自动重定向 HTTP 到 HTTPS</span></span><br><span class="line">    return <span class="number">301</span> https:<span class="regexp">//</span><span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    1.    <strong>证书路径</strong>：替换了自签名证书的路径（&#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx-selfsigned.crt 和 &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx-selfsigned.key），改为 certbot 获取的证书路径：</p>
<p>​    •    &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your_domain&#x2F;fullchain.pem：证书链文件。</p>
<p>​    •    &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your_domain&#x2F;privkey.pem：私钥文件。</p>
<p>​    2.    <strong>HTTP 到 HTTPS 重定向</strong>：确保所有从 HTTP 端口（80）进入的请求都会被自动重定向到 HTTPS（443）端口。</p>
<p>​    3.    <strong>续订检查</strong>：使用 certbot renew –dry-run 命令来模拟续订过程，确保 SSL 证书的续订顺利进行。</p>
<p>​    4.    <strong>注意</strong>：将 your_domain 替换为实际的域名，certbot 会自动为你配置 SSL 证书。</p>
<p>当你完成配置后，运行 sudo certbot –nginx -d your_domain 来获取免费的 SSL 证书，并自动更新你的 Nginx 配置。</p>
<p>gunicorn 免费获取SSL证书方法如下：</p>
<p>nginx 配置：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate <span class="regexp">/etc/</span>letsencrypt<span class="regexp">/live/y</span>our_domain/fullchain.pem;</span><br><span class="line">    ssl_certificate_key <span class="regexp">/etc/</span>letsencrypt<span class="regexp">/live/y</span>our_domain/privkey.pem;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment"># dev</span></span><br><span class="line">        proxy_pass http:<span class="regexp">//u</span>nix:<span class="regexp">/tmp/gu</span>nicorn.sock;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/static/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/</span>collectedstatic/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location <span class="regexp">/media/</span> &#123;</span><br><span class="line">        alias <span class="regexp">/Users/</span>fanyong<span class="regexp">/Desktop/</span>code<span class="regexp">/DjangoBlog/u</span>ploads/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自动重定向 HTTP 到 HTTPS</span></span><br><span class="line">    return <span class="number">301</span> https:<span class="regexp">//</span><span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    1.    <strong>证书路径</strong>：替换了自签名证书的路径，改为 certbot 获取的证书路径：</p>
<p>​    •    &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your_domain&#x2F;fullchain.pem：证书链文件。</p>
<p>​    •    &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your_domain&#x2F;privkey.pem：私钥文件。</p>
<p>​    •    请将 your_domain 替换为你实际的域名。</p>
<p>​    2.    <strong>SSL 配置</strong>：</p>
<p>​    •    启用 TLSv1.2 和 TLSv1.3 协议。</p>
<p>​    •    强制使用高强度的加密套件，禁用 NULL 和 MD5。</p>
<p>​    •    启用 ssl_prefer_server_ciphers，使服务器优先使用指定的加密套件。</p>
<p>​    3.    <strong>HTTP 到 HTTPS 重定向</strong>：确保所有从 HTTP 端口（80）进入的请求都被自动重定向到 HTTPS（443）端口。</p>
<p><strong>自动续订：</strong></p>
<p>确保定期续订 SSL 证书，可以设置自动续订（例如通过 cron 任务）。你可以运行以下命令来模拟续订：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo certbot renew <span class="comment">--dry-run</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 certbot 获取证书：</strong></p>
<p>如果尚未为 your_domain 获取证书，可以使用以下命令：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo certbot <span class="comment">--nginx -d your_domain</span></span><br></pre></td></tr></table></figure>

<p>确保 gunicorn 和 Nginx 都配置正确，这样可以顺利通过 HTTPS 提供服务。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web开发</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>接口幂等性</title>
    <url>/article/a26b78e0.html</url>
    <content><![CDATA[<p>1，高并发下如何保证接口的幂等性</p>
<p>​    1，insert 之前先根据name 或者 code 进行 select,如果数据存在则进行 update 操作，不存在执行 insert,</p>
<p>​    2, 加悲观锁，在同一事务操作过程中锁住一行数据，其他请求等待，</p>
<p>​    3，加乐观锁，判断操作影响行数，如果影响 1 行其他数据操作，如果 0 行直接返回值成功。</p>
<p>​    4，添加唯一索引，当出现相同请求时会抛出索引异常，</p>
<p>​    5，建防止重复的表，表中字段主要包含 id 和唯一索引，插入数据之前会先走防重表，判断唯一索引是否存在。</p>
<p>​    6，通过状态进行处理，例如已支付的状态是已完成。</p>
<h2 id="1-insert前先select"><a href="#1-insert前先select" class="headerlink" title="1. insert前先select"></a>1. insert前先select</h2><p>通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在<code>insert</code>前，先根据<code>name</code>或<code>code</code>字段<code>select</code>一下数据。如果该数据已存在，则执行<code>update</code>操作，如果不存在，才执行  <code>insert</code>操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrFw4QIBGFicltUPsasY7lgUVEK7cVLS1GK3mibMW5Jcy4t1TvNmaBnGew/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。我在这里提一下，是为了避免大家踩坑。</p>
<h2 id="2-加悲观锁"><a href="#2-加悲观锁" class="headerlink" title="2. 加悲观锁"></a>2. 加悲观锁</h2><p>在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的：</p>
<p>- </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="title">amount</span> = amount-<span class="number">100</span> where <span class="attr">id=</span><span class="number">123</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。</p>
<p>为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。</p>
<p>通常情况下通过如下sql锁住单行数据：</p>
<p>- </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> id=<span class="number">123</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体流程如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrlFMScuviaupFRboxZnOVWkojRVNxya7e2a0BUvnU7cwcAw9jYMLvJXw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>多个请求同时根据id查询用户信息。</li>
<li>判断余额是否不足100，如果余额不足，则直接返回余额不足。</li>
<li>如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。</li>
<li>只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。</li>
<li>第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。</li>
<li>如果余额不足，说明是重复请求，则直接返回成功。</li>
</ol>
<blockquote>
<p>需要特别注意的是：如果使用的是mysql数据库，存储引擎必须用innodb，因为它才支持事务。此外，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。</p>
</blockquote>
<p>悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能。</p>
<p>此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。</p>
<p>在这里顺便说一下，<code>防重设计</code> 和 <code>幂等设计</code>，其实是有区别的。防重设计主要为了避免产生重复数据，对接口返回没有太多要求。而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。</p>
<h2 id="3-加乐观锁"><a href="#3-加乐观锁" class="headerlink" title="3. 加乐观锁"></a>3. 加乐观锁</h2><p>既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个<code>timestamp</code>或者<code>version</code>字段，这里以<code>version</code>字段为例。</p>
<p>在更新数据之前先查询一下数据：</p>
<p>- </p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">select <span class="built_in">id</span>,amount,<span class="built_in">version</span> <span class="keyword">from</span> user <span class="built_in">id</span>=<span class="number">123</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果数据存在，假设查到的<code>version</code>等于<code>1</code>，再使用<code>id</code>和<code>version</code>字段作为查询条件更新数据：</p>
<h2 id=""><a href="#" class="headerlink" title="- "></a>- </h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">update<span class="built_in"> user </span><span class="builtin-name">set</span> <span class="attribute">amount</span>=amount+100,version=version+1where <span class="attribute">id</span>=123 <span class="keyword">and</span> <span class="attribute">version</span>=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更新数据的同时<code>version+1</code>，然后判断本次<code>update</code>操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。</p>
<p>由于第一次请求<code>version</code>等于<code>1</code>是可以成功的，操作成功后<code>version</code>变成<code>2</code>了。这时如果并发的请求过来，再执行相同的sql：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="- "></a>- </h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">update<span class="built_in"> user </span><span class="builtin-name">set</span> <span class="attribute">amount</span>=amount+100,version=version+1where <span class="attribute">id</span>=123 <span class="keyword">and</span> <span class="attribute">version</span>=1;</span><br></pre></td></tr></table></figure>

<p>该<code>update</code>操作不会真正更新数据，最终sql的执行结果影响行数是<code>0</code>，因为<code>version</code>已经变成<code>2</code>了，<code>where</code>中的<code>version=1</code>肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为<code>version</code>值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。</p>
<p>具体流程如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrVUKwejvF2k3OTVPD2JPAiaV5diaMl16ictoclcWwgcvJsMV8mibVOartVg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>先根据id查询用户信息，包含version字段</li>
<li>根据id和version字段值作为where条件的参数，更新用户信息，同时version+1</li>
<li>判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。</li>
<li>如果影响0行，说明是重复请求，则直接返回成功。</li>
</ol>
<h2 id="4-加唯一索引"><a href="#4-加唯一索引" class="headerlink" title="4. 加唯一索引"></a>4. 加唯一索引</h2><p>绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。</p>
<p>- </p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">alter table `order` add UNIQUE KEY `un_code` (`code`)<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报<code>Duplicate entry &#39;002&#39; for key &#39;order.un_code</code>异常，表示唯一索引有冲突。</p>
<p>虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。</p>
<p>如果是<code>java</code>程序需要捕获：<code>DuplicateKeyException</code>异常，如果使用了<code>spring</code>框架还需要捕获：<code>MySQLIntegrityConstraintViolationException</code>异常。</p>
<p>具体流程图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrs24WBMr0ktqAewryz7neZsASO9B8Qseqb8ict8CyLyia8lzv2YlY5LQQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>用户通过浏览器发起请求，服务端收集数据。</li>
<li>将该数据插入mysql</li>
<li>判断是否执行成功，如果成功，则操作其他数据（可能还有其他的业务逻辑）。</li>
<li>如果执行失败，捕获唯一索引冲突异常，直接返回成功。</li>
</ol>
<h2 id="5-建防重表"><a href="#5-建防重表" class="headerlink" title="5. 建防重表"></a>5. 建防重表</h2><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。</p>
<p>针对这种情况，我们可以通过<code>建防重表</code>来解决问题。</p>
<p>该表可以只包含两个字段：<code>id</code> 和 <code>唯一索引</code>，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。</p>
<p>具体流程图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrbAGE1PLlnV6ibnZcTeNeyic7bv6jewYbu1Tfo7KO99iciaZcbf5icgSPovA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>用户通过浏览器发起请求，服务端收集数据。</li>
<li>将该数据插入mysql防重表</li>
<li>判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑）。</li>
<li>如果执行失败，捕获唯一索引冲突异常，直接返回成功。</li>
</ol>
<blockquote>
<p>需要特别注意的是：防重表和业务表必须在同一个数据库中，并且操作要在同一个事务中。</p>
</blockquote>
<h2 id="6-根据状态机"><a href="#6-根据状态机" class="headerlink" title="6. 根据状态机"></a>6. 根据状态机</h2><p>很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。</p>
<p>假如id&#x3D;123的订单状态是<code>已支付</code>，现在要变成<code>完成</code>状态。</p>
<p>- </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">update `order` <span class="builtin-name">set</span> <span class="attribute">status</span>=3 where <span class="attribute">id</span>=123 <span class="keyword">and</span> <span class="attribute">status</span>=2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次请求时，该订单的状态是<code>已支付</code>，值是<code>2</code>，所以该<code>update</code>语句可以正常更新数据，sql执行结果的影响行数是<code>1</code>，订单状态变成了<code>3</code>。</p>
<p>后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了<code>3</code>，再用<code>status=2</code>作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是<code>0</code>，即不会真正的更新数据。但为了保证接口幂等性，影响行数是<code>0</code>时，接口也可以直接返回成功。</p>
<p>具体流程图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrWHME47uFVibJDCibIPILsuFib5nq3batoka8m58tN42JdX4HgKSrKiaF9A/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>用户通过浏览器发起请求，服务端收集数据。</li>
<li>根据id和当前状态作为条件，更新成下一个状态</li>
<li>判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。</li>
<li>如果影响了0行，说明是重复请求，直接返回成功。</li>
</ol>
<blockquote>
<p>主要特别注意的是，该方案仅限于要更新的<code>表有状态字段</code>，并且刚好要更新<code>状态字段</code>的这种特殊情况，并非所有场景都适用。</p>
</blockquote>
<h2 id="7-加分布式锁"><a href="#7-加分布式锁" class="headerlink" title="7. 加分布式锁"></a>7. 加分布式锁</h2><p>其实前面介绍过的<code>加唯一索引</code>或者<code>加防重表</code>，本质是使用了<code>数据库</code>的<code>分布式锁</code>，也属于分布式锁的一种。但由于<code>数据库分布式锁</code>的性能不太好，我们可以改用：<code>redis</code>或<code>zookeeper</code>。</p>
<p>鉴于现在很多公司分布式配置中心改用<code>apollo</code>或<code>nacos</code>，已经很少用<code>zookeeper</code>了，我们以<code>redis</code>为例介绍分布式锁。</p>
<p>目前主要有三种方式实现redis的分布式锁：</p>
<ol>
<li>setNx命令</li>
<li>set命令</li>
<li>Redission框架</li>
</ol>
<p>每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。</p>
<p>具体流程图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrkm3ibIJnLzKpwSdxcSPGh8lfuCCGLO2QVnYp2msIvLgoLuHsyOjHdWQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。</li>
<li>使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。</li>
<li>判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。</li>
<li>如果设置失败，说明是重复请求，则直接返回成功。</li>
</ol>
<blockquote>
<p>需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费<code>redis</code>的存储空间，需要根据实际业务情况而定。</p>
</blockquote>
<h2 id="8-获取token"><a href="#8-获取token" class="headerlink" title="8. 获取token"></a>8. 获取token</h2><p>除了上述方案之外，还有最后一种使用<code>token</code>的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。</p>
<ol>
<li>第一次请求获取<code>token</code></li>
<li>第二次请求带着这个<code>token</code>，完成业务操作。</li>
</ol>
<p>具体流程图如下：</p>
<p>第一步，先获取token。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNria8KH0Xlc6tLA05Dgn3FB3Nh7ly35Opicr00B1r0TXmnySicxz9udYTvw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>第二步，做具体业务操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrZ9rr3cexBOlVKicQgyzt45GyzrTZuJsvyvFJtxiaD0DRQqzJBPDgQarg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：</p>
<ol>
<li>用户访问页面时，浏览器自动发起获取token请求。</li>
<li>服务端生成token，保存到redis中，然后返回给浏览器。</li>
<li>用户通过浏览器发起请求时，携带该token。</li>
<li>在redis中查询该token是否存在，如果不存在，说明是第一次请求，做则后续的数据操作。</li>
<li>如果存在，说明是重复请求，则直接返回成功。</li>
<li>在redis中token会在过期时间之后，被自动删除。</li>
</ol>
<p>以上方案是针对幂等设计的。</p>
<p>如果是防重设计，流程图要改改：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNre6icZQjbP3KBARnjq206CBPiaDnUT8EGlgW47MmbXlEMZLY3ApMCkDmw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>需要特别注意的是：token必须是全局唯一的。</p>
</blockquote>
]]></content>
      <categories>
        <category>接口幂等性</category>
      </categories>
      <tags>
        <tag>接口幂等性</tag>
      </tags>
  </entry>
  <entry>
    <title>web开发2_python项目部署</title>
    <url>/article/dbe3cbd9.html</url>
    <content><![CDATA[<p>pm2运行命令:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">pm2 ls</span><br><span class="line">pm2 start xxx.py --<span class="keyword">name</span> mynodeapp</span><br><span class="line">pm2 startup</span><br><span class="line">pm2 <span class="keyword">save</span></span><br><span class="line">pm2 <span class="keyword">stop</span></span><br><span class="line">pm2 <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>python文件运行命令:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">nohup python3 -u risk_sql.py &gt;risk.log &amp;</span><br><span class="line">pm2 start <span class="regexp">/home/</span><span class="keyword">project</span><span class="regexp">/net_diagnose/</span>sanit.py --interpreter python3 --name sanit_script</span><br></pre></td></tr></table></figure>

<p>运行flask:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">env <span class="attribute">FLASK_APP</span>=scheduler.py flask <span class="builtin-name">run</span> -h 0.0.0.0 -p 5008</span><br></pre></td></tr></table></figure>

<p>通过 gunicorn 启动</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">nohup gunicorn -b 0.0.0.0:9000 -w 4 <span class="keyword">app</span>:<span class="keyword">app</span> &gt; nohup.<span class="keyword">log</span> &amp;</span><br><span class="line">说明：</span><br><span class="line">	-b： bind，ip+port</span><br><span class="line">	# <span class="keyword">mac</span>:echo $(( $(sysctl -<span class="keyword">n</span> hw.ncpu) * 2 + 1 ))	linux: echo $(( $(nproc) * 2 + 1 ))</span><br><span class="line">	-w:	 workers:cpu 核心数 x 2 + 1s 	</span><br><span class="line">	<span class="keyword">app</span>:<span class="keyword">app</span>	模块名:应用对象名</span><br><span class="line">			•	第一个 <span class="keyword">app</span>：Python 文件 <span class="keyword">app</span>.py（即 <span class="keyword">app</span>.py 文件）。</span><br><span class="line">			•	第二个 <span class="keyword">app</span>：在 <span class="keyword">app</span>.py 文件中定义的 Flask 应用对象（例如 <span class="keyword">app</span> = Flask(__name__)）。</span><br><span class="line">			适用于 Flask。如果是 Django，通常是 myproject.wsgi。</span><br></pre></td></tr></table></figure>

<p>Supervisor：进程管理工具</p>
<p>安装：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">sudo apt update &amp;&amp; sudo apt <span class="keyword">install</span> supervisor -y / sudo yum <span class="keyword">install</span> supervisor -y</span><br><span class="line">mac：</span><br><span class="line">brew <span class="keyword">install</span> supervisor</span><br></pre></td></tr></table></figure>

<p>配置：位于 &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F; 目录，每个进程都有一个单独的 .conf 文件。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:gunicorn]</span></span><br><span class="line"><span class="attr">command</span>=/usr/local/bin/gunicorn -w <span class="number">4</span> -b <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span> app:app</span><br><span class="line"><span class="attr">directory</span>=/home/user/myproject</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/gunicorn.err.log</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/gunicorn.out.log</span><br></pre></td></tr></table></figure>

<p>启动并加载配置：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">sudo supervisorctl reread</span><br><span class="line">sudo supervisorctl update</span><br><span class="line">sudo supervisorctl start gunicorn</span><br><span class="line"><span class="meta"># 查看进程状态</span></span><br><span class="line">sudo supervisorctl status</span><br><span class="line"><span class="meta"># 停止进程</span></span><br><span class="line">sudo supervisorctl stop gunicorn</span><br><span class="line"><span class="meta"># 重启进程</span></span><br><span class="line">sudo supervisorctl restart gunicorn</span><br><span class="line"><span class="meta"># 重新加载所有进程</span></span><br><span class="line">sudo supervisorctl reload</span><br></pre></td></tr></table></figure>

<p>supervisorctl + <strong>Django &#x2F; Flask + Gunicorn</strong> &#x2F; supervisorctl + celery</p>
<p>eg1：<strong>Django + Gunicorn + Supervisor + Nginx</strong></p>
<p>创建supervisor配置： vim &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;django_gunicorn.conf</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># gunicorn</span><br><span class="line">#[program:django_gunicorn]</span><br><span class="line">#command=<span class="regexp">/usr/</span>local<span class="regexp">/bin/gu</span>nicorn -w <span class="number">4</span> -b <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span> myproject.wsgi:application</span><br><span class="line"># uwsgi</span><br><span class="line"># [program:uwsgi]</span><br><span class="line">#command=<span class="regexp">/usr/</span>local<span class="regexp">/bin/u</span>wsgi --ini <span class="regexp">/home/u</span>ser<span class="regexp">/myproject/u</span>wsgi.ini</span><br><span class="line"># celery</span><br><span class="line">[program:celery]</span><br><span class="line">command=<span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>celery -A myproject worker --loglevel=info</span><br><span class="line">directory=<span class="regexp">/home/u</span>ser/myproject</span><br><span class="line">autostart=<span class="keyword">true</span></span><br><span class="line">autorestart=<span class="keyword">true</span></span><br><span class="line">stderr_logfile=<span class="regexp">/var/</span>log/gunicorn.err.log</span><br><span class="line">stdout_logfile=<span class="regexp">/var/</span>log/gunicorn.out.log</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sudo supervisorctl reread</span><br><span class="line">sudo supervisorctl <span class="keyword">update</span></span><br><span class="line"># sudo supervisorctl <span class="keyword">start</span> django_gunicorn</span><br><span class="line"># sudo supervisorctl <span class="keyword">start</span> uwsgi</span><br><span class="line">sudo supervisorctl <span class="keyword">start</span> celery</span><br></pre></td></tr></table></figure>

<p>配置 nginx，参考 nginx 部署</p>
<p>启动 nginx 并重启：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/my</span><span class="keyword">project</span> <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span></span><br><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>



<p><strong>Docker + Gunicorn + Nginx + PostgreSQL&#x2F;MySQL&#x2F;Redis</strong>容器化部署</p>
<p>安装：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker（Ubuntu）</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt <span class="keyword">install</span> -y docker.io</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker Compose</span></span><br><span class="line">sudo apt <span class="keyword">install</span> -y docker-compose</span><br></pre></td></tr></table></figure>

<p>验证安装</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">docker <span class="comment">--version</span></span><br><span class="line">docker-compose <span class="comment">--version</span></span><br></pre></td></tr></table></figure>

<p>目录结构：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">myproject/</span><br><span class="line">│── app/                  <span class="meta"># Python Web 应用代码</span></span><br><span class="line">│   ├── main.py           <span class="meta"># Flask/FastAPI 入口文件 或 Django manage.py</span></span><br><span class="line">│   ├── requirements.txt  <span class="meta"># Python 依赖包</span></span><br><span class="line">│   ├── Dockerfile        <span class="meta"># Docker 镜像构建文件</span></span><br><span class="line">│── nginx/                <span class="meta"># Nginx 配置</span></span><br><span class="line">│   ├── <span class="literal">default</span>.conf</span><br><span class="line">│── docker-compose.yml    <span class="meta"># Docker Compose 配置</span></span><br><span class="line">│── .env                  <span class="meta"># 环境变量文件</span></span><br></pre></td></tr></table></figure>

<p>flask包（flask    gunicorn）</p>
<p>django包（django    gunicorn    psycopg2  # PostgreSQL 数据库驱动）</p>
<p>编写Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Gunicorn 服务器</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-b&quot;</span>, <span class="string">&quot;0.0.0.0:5000&quot;</span>, <span class="string">&quot;main:app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>django如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">CMD <span class="selector-attr">[<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-b&quot;</span>, <span class="string">&quot;0.0.0.0:8000&quot;</span>, <span class="string">&quot;myproject.wsgi:application&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>配置nginx(参考nginx部署):</p>
<p>编写<strong>docker-compose.yml</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  app:</span></span><br><span class="line"><span class="symbol">    build:</span> .</span><br><span class="line"><span class="symbol">    container_name:</span> python_app</span><br><span class="line"><span class="symbol">    restart:</span> always</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line">      - DEBUG=False</span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - db</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">  db:</span></span><br><span class="line"><span class="symbol">    image:</span> postgres:<span class="number">13</span></span><br><span class="line"><span class="symbol">    container_name:</span> postgres_db</span><br><span class="line"><span class="symbol">    restart:</span> always</span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line"><span class="symbol">      POSTGRES_USER:</span> user</span><br><span class="line"><span class="symbol">      POSTGRES_PASSWORD:</span> password</span><br><span class="line"><span class="symbol">      POSTGRES_DB:</span> mydatabase</span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - postgres_data:<span class="meta-keyword">/var/</span>lib<span class="meta-keyword">/postgresql/</span>data</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">  nginx:</span></span><br><span class="line"><span class="symbol">    image:</span> nginx:latest</span><br><span class="line"><span class="symbol">    container_name:</span> nginx_server</span><br><span class="line"><span class="symbol">    restart:</span> always</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - .<span class="meta-keyword">/nginx/</span>default.conf:<span class="meta-keyword">/etc/</span>nginx/conf.d/default.conf</span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - app</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">volumes:</span></span><br><span class="line"><span class="symbol">  postgres_data:</span></span><br></pre></td></tr></table></figure>

<p>docker镜像构建：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose build</span></span><br></pre></td></tr></table></figure>

<p>启动所有容器：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure>

<p>查看运行状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure>

<p>进入容器：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> python_app bash</span><br></pre></td></tr></table></figure>

<p>停止和删除容器</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose down</span></span><br></pre></td></tr></table></figure>

<p> <strong>配置 docker-compose.override.yml（可选）</strong></p>
<p>用于本地开发（映射本地代码，实时更新）：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  app:</span></span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - .:/app</span><br></pre></td></tr></table></figure>

<p>自动重启 Docker容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="builtin-name">enable</span> docker</span><br></pre></td></tr></table></figure>

<p>使用Supervisor 管理</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:docker_compose]</span></span><br><span class="line"><span class="attr">command</span>=/usr/local/bin/docker-compose up</span><br><span class="line"><span class="attr">directory</span>=/home/user/myproject</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/docker.err.log</span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/docker.out.log</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sudo supervisorctl reread</span><br><span class="line">sudo supervisorctl <span class="keyword">update</span></span><br><span class="line">sudo supervisorctl <span class="keyword">start</span> docker_compose</span><br></pre></td></tr></table></figure>

<p>docker部署 HTTPS(SSL 证书)</p>
<p>方法 1：<strong>使用 Let’s Encrypt + Certbot</strong></p>
<p>使用 ssl 证书</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt install certbot <span class="keyword">python3</span>-certbot-nginx -<span class="keyword">y</span></span><br><span class="line">sudo certbot --nginx -d mydomain.<span class="keyword">com</span></span><br></pre></td></tr></table></figure>

<p>自动续订</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo certbot renew <span class="comment">--dry-run</span></span><br></pre></td></tr></table></figure>

<p>方法 2：nginx 配置：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name mydomain.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>fullchain.pem;</span><br><span class="line">    ssl_certificate_key <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span>privkey.pem;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="regexp">//</span>app:<span class="number">5000</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架使用</title>
    <url>/article/1d5ab057.html</url>
    <content><![CDATA[<p>1,Scrapy的安装配置(根据个人实际情况,每个人项目不一样)<br>①,先安装将twisted文件放到E盘根目录下<br>#前提必须安装wheel模块,为了安装whl文件<br>②,E:—&gt;pip install Twisted-18.4.0-cp36-cp36m-win_amd64.whl<br>③,pip install scrapy&#x3D;&#x3D;1.5.0</p>
<p>2,在E盘创建Scrapy工程:<br>E: —&gt; scrapy startproject doubanmovie —&gt;<br>cd doubanmovie —&gt;scrapy genspider moviespider douban.com</p>
<p>3,爬虫主程序的编写:<br>在Pycharm工具打开doubanmovie下级目录的doubanmovie<br>①,添加浏览器标识<br>将rotate_useragent文件放到doubanmovie文件夹下<br>②,在settings中的DOWNLOAD_MIDDLEWARES中添加配置信息<br>添加禁用框架自带的浏览器标识及设置浏览器标识<br>#禁用框架自带的浏览器标识<br>‘scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware’: None,<br>#设置浏览器标识<br>‘doubanmovie.rotate_useragent.RotateUserAgentMiddleware’:400<br>②-①,编写settings,py,启动管道组件,ITEM_PIPELINES 以及其他相关设置</p>
<p>③,编写主程序</p>
<p>④,执行<br>scrapy crawl (spiders下文件,不包含后缀)</p>
<p>注意:设置浏览器标识时,第一个应为项目名</p>
<p>爬虫爬取数据流程(scrapy)<br>1,scrapy startproject XXXX<br>2,scrapy genspider XXXX “<a href="http://www.xxxx.com”/">http://www.XXXX.com”</a><br>3,编写item.py,明确需要提取的数据<br>4,编写spiders&#x2F;xxxx.py ,编写爬虫文件,处理请求和响应,以及提取数据(yield item )<br>5,编写pipelines.py , 编写管道文件,处理spider返回item,比如本地持久化存储等…<br>6,编写settings,py,启动管道组件,ITEM_PIPELINES 以及其他相关设置<br>7,执行爬虫</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow概念整理</title>
    <url>/article/e5f5d28.html</url>
    <content><![CDATA[<p>Tensorflow使用学习说明:</p>
<p>1,环境配置(Window环境下):</p>
<p><a href="https://support.microsoft.com/zh-cn/topic/%E6%9C%80%E6%96%B0%E6%94%AF%E6%8C%81%E7%9A%84-visual-c-%E4%B8%8B%E8%BD%BD-2647da03-1eea-4433-9aff-95f26a218cc0">软件链接地址</a></p>
<p>安装VC_redist.x64.exe软件,Microsoft Visual C++ 环境</p>
<p>2,安装tensorflow,</p>
<p>版本说明:</p>
<p>针对电脑CUDA大小下载不同版本的tensorflow</p>
<p><a href="https://tensorflow.google.cn/install/source_windows">对应关系</a></p>
<p><a href="https://blog.csdn.net/qq_38295511/article/details/89223169">查看CUDA方法</a></p>
<p>①打开控制面板</p>
<p>②搜索NVIDIA控制面板</p>
<p>③点击系统信息</p>
<p>④点击组件</p>
<p>⑤通过NVCUDA.DLL查看CUDA版本</p>
<p>eg:本机的CUDA版本为11.3.55 , 对应的tensorflow版本为2.4.0</p>
<p>下载方式为:<a href="https://pypi.org/project/tensorflow/2.4.0/#files">https://pypi.org/project/tensorflow/2.4.0/#files</a></p>
<p>pip install 包名</p>
<p>线性回归和梯度下降算法</p>
<p>单变量线性回归算法: f(x) &#x3D; ax + b,映射输入特征和输出值</p>
<p>#绘制点状图,受教育年限和收入之间的线性关系: f(x) &#x3D; ax + b </p>
<p>预测目标与损失函数</p>
<p>目标:</p>
<pre><code>预测函数f(x)与真实值之间的整体误差最小

如何定义误差最小
</code></pre>
<p>损失函数:</p>
<pre><code>使用均方差作为成本函数,

均方差:

    预测值和真实值之间差的平方取均值
</code></pre>
<p>成本函数与损失函数</p>
<p>优化目标(y代表实际的收入)</p>
<p>找到合适的a和b,使(f(x)-y)²越小越好  —&gt;成本函数(均方差)    [f(x) &#x3D; ax + b]    —&gt;  ((ax + b) - y)²值最小</p>
<p>已知:x和y</p>
<p>注意: 求解的是参数a和b</p>
<p>成本函数与损失函数</p>
<p>如何优化:</p>
<p>使用梯度下降算法</p>
<p>梯度下降算法:</p>
<pre><code>是一种致力于找到函数极值点的算法,将梯度下降算法应用于寻找损失函数的极值点便构成了依据输入数据的模型学习

梯度的输出是一个由若干偏导数构成的向量,它的每个分量对应于函数对输入向量的相应分量的偏导  (查找之前学过的求偏导)


梯度的输出向量表明了在每个位置损失函数增长最快的方向,可将它视为表示了在函数的每个位置向哪个方向移动函数值可以增长
</code></pre>
<p>多层感知器(神经网络与激活函数)</p>
<p>输入(x1,x2,x3) 1    权重(w1,w2,w3)b    求和       传递函数    输出      </p>
<p>生物的神经元一层一层连接起来,当神经信号达到某一条件,这个神经元就会激活,然后传递信息下去,</p>
<p>为了继续使用神经网络解决这种不具备线性可分性的问题,采取在神经网络的输入端和输出端之间插入更多的神经元</p>
<p>输入层 —&gt; 隐含层 —&gt; 输出层 —&gt; 输出</p>
<p>神经元的启发</p>
<p>激活函数:</p>
<p>relu</p>
<p>sigmoid(查看之前公式)</p>
<p>tanh</p>
<p>leak relu</p>
<p>广告,销量的预测</p>
<p>逻辑回归</p>
<p>sigmoid函数是一个概率分布函数,给定某个输入,它将输出为一个概率值</p>
<p>0~1之间的一个概率值</p>
<p>线性回归预测的是一个连续值,</p>
<p>逻辑回归给出的 “是” 和 “否”的回答</p>
<p>逻辑回归损失函数</p>
<p>平方差所惩罚的是与损失为同一数量级的的情形</p>
<p>对于分类问题,我们最好的使用交叉熵损失函数会更有效</p>
<p>交叉熵会输出一个更大的 “损失”</p>
<p>交叉熵损失函数</p>
<p>交叉熵刻画的是实际输出(概率)与期望输出(概率)的距离,也就是交叉熵的值越小,两个概率分布就越接近.假设概率分布p为期望输出,概率分布q为实际输出,H(p,q)为交叉熵,</p>
<p>$$<br>H(p,q) &#x3D; -\sum_{x}p(x)logq(x)<br>$$<br>在keras里,使用binary_crossentropy来计算交叉熵</p>
<p>Softmax分类</p>
<p>对数几率回归解决的是二分类的问题</p>
<p>对于多个选项的问题,我们可以使用softmax函数</p>
<p>它是对数几率回归在N个可能不同的值上的推广</p>
<p>神经网络的原始输出不是一个概率值,实际上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已,那么如何将这个输出变为概率分布</p>
<p>这就是Softmax层的作用</p>
<p>softmax要求每个样本必须属于某个类别,且所有可能的样本均被覆盖</p>
<p>softmax个样本分量之和为1</p>
<p>当只有两个类别时,与对数几率回归完全相同</p>
<p>在tf.keras里,对于多分类问题使用categorical_crossentropy和sparse_categorical_crossentopy来计算softmax交叉熵</p>
<p>Fashion MNIST数据集: 70000张灰度图像,10个类别  :衣物</p>
<p>Fashion MNIST的作用是成为经典MNIST数据集的简易替换,MNIST数据集包含手写数字(0,1,2等)的图像,这些图像的格式与本节课中使用的服饰图像的格式相同</p>
<p>Fashion MNIST比常规MNIST手写数据集更挑战性.</p>
<p>这两个数据集都相对较小.用于验证某个算法能否如期正常运行,它们都是测试和调试代码的良好起点</p>
<p>MNIST手写数据集将作为作业交给大家自己完成\</p>
<p>使用60000张图像训练网络,使用10000张图像评估经过学习的网络分类图像的准确率</p>
<p>可以从Tensorflow 直接访问Fashion MNIST, 只需导入和加载数据即可</p>
<p>优化函数,学习速率,反向传播算法</p>
<p>学习速率:</p>
<pre><code>梯度就是表明损失函数相对参数的变化率

对梯度进行缩放的参数被称为学习速率

学习速率是一种超参数或对模型的一种手工可配置的设置
</code></pre>
<p> 需要为它指定正确的值. 如果学习速率太小,则找到损失函数极小值点时可能需要许多迭代,如果太大,则算法可能会 “跳过” 极小值点并且因周期性的 “跳跃” 而永远无法找到极小值点</p>
<p>在具体实践中,可以通过查看损失函数值随时间的变化曲线,来判断学习速率的选取是合适的</p>
<p>合适的学习速率,损失函数会随时间下降,直到一个底部,不合适的学习速率,损失函数可能会发生震荡</p>
<p>在调整学习速率时,既需要使其足够小,保证不至于发生超调,也要保证它足够大,以使损失函数能够尽快下降,从而可通过较少次数的迭代更快的完成学习</p>
<p>反向传播算法:</p>
<pre><code>反向传播算法是一种高效计算数据流图中梯度的技术

每一层的导数都是后一层的导数与前一层输出之积,这正是链式法则的奇妙之处,误差反向传播算法利用的正是这一特点
</code></pre>
<p>前馈时,从输入开始,逐一计算每个隐含层的输出,直到输出层</p>
<p>然后开始计算导数,并从输出层经各隐含层逐一反向传播,为了减少计算量,还需对所有已完成的元素进行复用,这便是反向传播算法名称的由来</p>
<p>常见的优化函数</p>
<p>优化器是编译模型所需的两个参数之一</p>
<p>你可以先实例化一个优化器对象,然后将它传入</p>
<p>model.compile(),或者你可以通过名称来调用优化器,在后一种情况下,将使用优化器的默认参数</p>
<p>1,SGD:随机梯度下降优化器</p>
<p>随机梯度下降优化器SGD和min-batch是同一个意思,抽取m个小批量(独立同分布)样本,通过计算他们平均度均值</p>
<p>SGD参数(了解):</p>
<p>lr: float &gt;&#x3D; 0.学习率</p>
<p>momentum:float &gt;&#x3D; 0.参数,用于加速SGD在相关方向上前进,并抑制震荡</p>
<p>decay:float &gt;&#x3D; 0.每次参数更新后学习率衰减值</p>
<p>nesterov:boolean.是否使用Nesterov动量</p>
<p>RMSprop: 经验上,RMSProp被证明有效且实用的深度学习网络优化算法</p>
<p>RMSProp增加了一个衰减系数来控制历史信息的获取多少</p>
<p>RMSProp会对学习率进行衰减</p>
<p>建议使用优化器默认参数(除了学习率lr,它可以被自由调节)</p>
<p>这个优化器通常是训练神经网络RNN的不错选择</p>
<p>2,Adam优化器(最常用,用的最多)</p>
<pre><code>1,Adam优化器可以看做是修正后的Momentum+RMSProp算法

2,Adam通常被认为对超参数的选择相当棒

3,学习率建议为0.001
</code></pre>
<p>Adam是一种可以替代传统随机梯度下降过程的一阶优化算法,它能基于训练数据迭代地更新神经网络权重</p>
<p>Adam通过计算梯度的一阶矩估计和二阶矩估计而为不同的参数设计独立的自适应性学习率</p>
<p>参数:</p>
<p>lr: float &gt;&#x3D; 0.学习率</p>
<p>beta_1:float, 0 &lt; beta &lt; 1.通常接近于1</p>
<p>beta_2:float, 0 &lt; beta &lt; 1.通常接近于1</p>
<p>decay:float &gt;&#x3D; 0.每次参数更新后学习率衰减值</p>
<p>网络优化与参数选择</p>
<p>网络容量:</p>
<pre><code>与网络中的可训练参数成正比
</code></pre>
<p>网络中的神经单元数越多,层数越多,神经网络的拟合能力越强</p>
<p>但是训练速度,难度越大,越容易产生过拟合</p>
<p>如何选择超参数:</p>
<pre><code>就是在搭建神经网络中,需要我们自己如选择(不是通过梯度下降算法去优化)的那些参数
</code></pre>
<p>eg:中间层的神经元个数,学习速率</p>
<p>如何提高网络的拟合能力</p>
<p>一种显然的想法是增大网络容量</p>
<p>1,增加层(这个方法比较显著)</p>
<p>2,增加隐藏神经元个数</p>
<pre><code>注意:单层的神经元个数,不能太小,太小的话,会造成信息瓶颈,使得模型欠拟合
</code></pre>
<p>Dropout:可以解决过拟合</p>
<ol>
<li><p>取平均的作用:  先回到标准的模型即没有dropout我们用相同的训练数据区训练5个不同的神经网络,一般会得到5个不同的结果,此时我们可以采用 ‘5个结果取均值’ 或者 ‘多数取胜的投票策略’ 去决定最终结果</p>
</li>
<li><p>减少神经元之间复杂的共适应关系,因为dropout程序导致两个神经元不一定每次在一个dropout网络中出现,这样权值的更新不再依赖于有固定关系的隐含节点的共同作用,阻止了某些特征仅仅在其他特征下才有效果的情况</p>
</li>
</ol>
<p>3)类似于性别在生物进化中的角色</p>
<p>物种为了生存往往会倾向于适应这种环境,环境突变则会导致物种难以做出及时反映,性别的出现可以繁衍出适应新环境的变种,有效的阻止过拟合,即避免环境改变时物种可能面临的灭绝</p>
<p>参数选择的原则:</p>
<pre><code>理想的模型是刚好在欠拟合和过拟合的界线上,也就是正好拟合数据
</code></pre>
<p>首先开发一个过拟合的模型:</p>
<p>(1)添加更多的层</p>
<p>(2)让每一层变得更大</p>
<p>(3)训练更多的轮次</p>
<p>然后抑制过拟合:</p>
<p>(1)dropout</p>
<p>(2)正则化</p>
<p>(3)图像增强</p>
<p>再次,调节超参数,</p>
<p>学习速率</p>
<p>隐藏层单元数</p>
<p>训练轮次</p>
<p>超参数的选择是一个经验和不断测试的结果</p>
<p>经典机器学习的方法,如特征工程,增加训练数据也要做</p>
<p>交叉验证</p>
<p>构建网络的总原则:    保证神经网络容量足够拟合数据</p>
<p>一. 增大网络数量,知道过拟合</p>
<p>二, 采取措施抑制过拟合</p>
<p>三. 继续增大网络容量,直到过拟合</p>
]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>window快捷键</title>
    <url>/article/d1988cc4.html</url>
    <content><![CDATA[<p>1,calc:计算器</p>
<p>2,regedit;注册表编辑器</p>
<p>3,ipconfig:ip地址</p>
<p>4,win+L:锁屏</p>
<p>5,win+E:打开电脑</p>
<p>6,pycharm中:ctrl+r:多个替换</p>
<p>7,双击alt:电脑管家火箭加速</p>
<p>8,alt + tab:软件界面切换</p>
<p>9,tree &#x2F;f:显示目录结构</p>
<p>10,win+x  a:管理员命令操作提示符</p>
<p>11,选中模块,alt+enter:安装模块</p>
<p>12.alt用鼠标选中,多条修改</p>
<p>13,函数()内,ctrl+p:提示 </p>
<p>14,win + r :mspaint:画图快捷键</p>
<p>15,slidetoshutdown :关机快捷键</p>
<p>16,convert g:&#x2F;fs:ntfs :u盘文件过大,无法复制,g为u盘盘符</p>
<p>17,win + R :powershell:打开管理员模式</p>
<p>18,在linux打开pycharm:.&#x2F;pycharm.sh</p>
<p>19:定时关机:shutdown -s -t 秒数</p>
<p>20,ctrl+alt+del:进入任务管理器</p>
<p>21,打开服务:services.msc</p>
<p>22，远程连接：mstsc</p>
<p>23,删除多余服务(在根目录下):sc delete 服务器名称</p>
<p>24,查看电脑系统内存大小:win+r —&gt; msinfo32时区下的已安装物理内存就是笔记本内存大小</p>
<p>25,安装服务(根目录下|管理员权限):</p>
<p>安装: .\installService.cmd</p>
<p>卸载: .\uninstallService.cmd</p>
<p>26,C盘清理旧文件:</p>
<p>C盘—&gt;属性—&gt;磁盘清理—&gt;清理系统文件—&gt;以前的windows安装—&gt;确定</p>
<p>27,  关机: slidetoshutdown</p>
<p>28:  win10激活:</p>
<p>slmgr &#x2F;ipk W269N-WFGWX-YVC9B-4J6C9-T83GX </p>
<p>slmgr &#x2F;skms kms.03k.org</p>
<p>slmgr &#x2F;ato </p>
<p>28, win10打开系统属性快捷键:  dxdiag </p>
]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>window</tag>
      </tags>
  </entry>
  <entry>
    <title>yolo学习笔记</title>
    <url>/article/4ada0a.html</url>
    <content><![CDATA[<p>1,目录详解</p>
<p>assets:需要测试的不同类型的文件</p>
<p>datasets:存放的数据集,例如Coco</p>
<p>demo:官方提供的4种部署方式</p>
<p>docs数据集信息</p>
<p>exps:Yolo所有版本的数据集</p>
<p>tools:程序入口</p>
<p>demo.py :  测试文件</p>
<p>train.py: 也是测试文件</p>
<p>weights:权重文件</p>
<p>yolox:模型代码</p>
<p>2,环境</p>
<p>pyhon环境&#x2F;anaconda</p>
<p>pytorch</p>
<p>pycharm</p>
<p>下载环境:在根目录下输入pip install requirements.txt</p>
<p>3,运行</p>
<p>tools下的demo.py</p>
<p>parser.add_argument</p>
<p>约24行修改测试的类型 default &#x3D; ‘类型’</p>
<p>约28行修改测试的内容 default &#x3D; ‘源文件’</p>
<p>约39行修改权重的默认位置 default &#x3D; ‘具体权重文件位置’</p>
<p>约43行修改默认的权重 default &#x3D; ‘具体权重文件位置’</p>
<p>约44行修改默认的cpu&#x2F;gpu default &#x3D; ‘运行类型’</p>
<p>测试输出图像保存在tools&#x2F;YOLOX_output</p>
<p>数据集测试:步骤</p>
<p>1,安装apex:</p>
<p>pip install apex</p>
<p>减少模型显存占用的工具</p>
<p>2,修改train文件中的参数</p>
<p>2-1,修改patch,默认50,约30行</p>
<p>2-2,数据集路径:在yolo_voc_nano.py下约54行的data_dir &#x3D; ‘具体路径’</p>
<p>#55行修改:目录根据实际情况(可不修改)</p>
<p>train修改内容: </p>
<p>具体的文件目录:</p>
<p>40行.</p>
<p>权重修改:</p>
<p>47行</p>
<p>GPU使用修改为True:</p>
<p>68行左右</p>
<p>输出内容主要有:</p>
<p>权重信息目录</p>
<p>训练完成后,利用权重进行测试</p>
<p>测试在demo目录下修改</p>
<p>类别和内容</p>
<p>权重文件和训练时的权重文件一致 .py         39行 : yolox_voc_nano.py</p>
<p>43 行权重改为训练后保存的权重文件             </p>
]]></content>
      <categories>
        <category>目标识别</category>
      </categories>
      <tags>
        <tag>目标识别</tag>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title>web面试题</title>
    <url>/article/45b9fa15.html</url>
    <content><![CDATA[<p>1, Django的MVT模式(MVC:M相当于model,V相当于template,C相当于view)<br>M： Model, 模型 与MVC中的M相同，负责对数据的处理<br>V： View, 视图 与MVC中的C类似，负责处理用户请求，调用M和T，响应请求<br>T： Template, 模板 与MVC中的V类似，负责如何显示数据（产生html界面）</p>
<p>2, get&#x2F;post<br>GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
<p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
<p>GET请求在URL中传送的参数是有长度限制的，而POST没有。</p>
<p>GET参数通过URL传递，POST放在Request body中。</p>
<p>3,csrf</p>
<p>跨站请求伪造: 主要用于在html中设计token访问令牌</p>
<p>4,FBV&#x2F;CBV</p>
<p>FBV:基于函数视图</p>
<p>CBV:基于类视图</p>
<p>5, django请求周期</p>
<p>（1）用户输入网址，浏览器发起请求<br>（2）WSGI（服务器网关接口）创建socket服务端，接受请求<br>（3）中间件处理请求<br>（4）url路由，根据当前请求的url找到相应的视图函数<br>（5）进入view，进行业务处理，执行类或者函数，返回字符串<br>（6）再次通过中间件处理相应<br>（7）WSGI返回响应<br>（8）浏览器渲染</p>
<p>6,uwsgi</p>
<p>web服务器(应用服务器),用于连接Web服务器和Web应用框架</p>
<p>7,中间件</p>
<p>是一个轻量低级别的插件系统,在全局变量改变django的输入与输出,在settings中注册,,例如csrf跨站请求伪造</p>
<p>8,内置组件</p>
<p>Admin: 对model中对应的数据表进行增删改查提供的组件<br>model：负责操作数据库<br>form：1.生成HTML代码 2.数据有效性校验 3校验信息返回并展示<br>ModelForm: 即用于数据库操作,也可用于用户请求的验证</p>
<p>10, JWT</p>
<p>第一次认证通过用户名密码，服务端签发一个json格式的token。后续客户端的请求都携带这个token，服务端仅需要解析这个token，来判别客户端的身份和合法性</p>
<p>11,cookie和session<br>1.cookie:<br>cookie是保存在浏览器端的键值对,可以用来做用户认证<br>2.session：<br>将用户的会话信息保存在服务端,key值是随机产生的自符串,value值时session的内容<br>依赖于cookie将每个用户的随机字符串保存到用户浏览器上<br>Django中session默认保存在数据库中：django_session表flask,session默认将加密的数据写在用户的cookie中</p>
<p>12,  如何实现用户的登陆认证<br>1.cookie session<br>2.token 登陆成功后生成加密字符串<br>3.JWT：json wed token缩写 它将用户信息加密到token中,服务器不保存任何用户信息<br>服务器通过使用保存的密钥来验证token的正确性</p>
<p>13, restful风格<br>restful其实就是一套编写接口的协议，协议规定如何编写以及如何设置返回值、状态码等信息。</p>
<p>7,TCP&#x2F;UDP&#x2F;HTTP&#x2F;HTTPS的区别?<br> TCP协议:是一种面向连接,可靠的,基于字节流的传输层协议,在正式通信前必须和对方建立连接,一个tcp必须经过三次对话才能建立连接,在经历4次对话结束(即三握四挥),传输可靠,速度慢,应用,传输大量数据,对可靠性要求高</p>
<p>UDP协议:用于www浏览的协议,特点是客户端发送的请求都需要服务器回送响应,在请求结束后会主动释放连接,从建立连接到关闭连接的过程成为”一次连接” 注: 1)在http1.0中客户端的每次请求都要求建立一次单独的连接,在处理完本次请求后就自动释放连接 2)在http1.1中,则可以在一次连接中处理多次请求,并可重叠进行,不需要等一个请求结束后再发下一个请求</p>
<p>HTTP&#x2F;HTTPS协议 HTTP协议:超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP&#x2F;IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种 发布和接收HTML页面的方法。<br>HTTPS协议: HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。<br>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</p>
<p>8, http1.0与2.0,3.0的区别<br>http1.0存在连接无法复用问题,导致每发送一次请求都需要进行三次握手的过程,重新建立连接,效率太低,存在堵塞问题 ,http1.0是下一次请求的发送必须等到上一个请求返回后才会进行,如果上一个请求没有返回,name后面的请求就会全部堵塞,最后就是安全问题,http1.0所传输的内容都是明文的,无法保证数据的安全性.<br>http2.0比较专注性能,它采用二进制格式传输数据,http2.0也采用了多路复用的技术,他可以只通过一个TCP连接传输所有的请求数据,还有就是采用了头部压缩技术,这也解决了http1.0的header里携带的内容过大的问题,在一定程度上减轻了传输的成本,不过它也存在一定的问题,如果在传输的过程中存在丢包的情况的话,那么整个tcp就得重新传输,后面资源就会被堵塞.<br>http3.0放弃了tcp协议,改用了QUIC协议,此协议基于传输层UDP协议,UDP协议无需三次连接四次挥手,所以传输速率更高,如果出现丢包,只需要重发丢掉的包就可以.</p>
<p>20, Django 、Flask、Tornado的对比<br>1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器 给开发者提高了超高的开发效率<br>2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎<br>3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式<br>Tornado的两大核心模块：<br>1.iostraem：对非阻塞式的socket进行简单的封装<br>2.ioloop：对I&#x2F;O多路复用的封装，它实现了一个单例</p>
<p>17,分别从前端,后端,数据库阐述web项目的性能优化<br>前端优化:<br>①,减少http请求,例如制作精灵图<br>②,html和CSS放在页面上部,javascript放在页面下部</p>
<p>后端优化:<br>①,缓存存储读写次数高,变化少的数据,<br>②,异步方式,如果有耗时操作,可采用异步,如celery<br>③,代码优化,避免循环和判断次数太多,如果多个if else判断,优先判断最有可能发生的情况</p>
<p>数据库优化:<br>①,如有条件,数据可以存放于redis,读取速度快,<br>②,建立索引,外键等</p>
<p>32,当后端任务执行完成后如何通知前端<br>1,前端定时发送请求询问后端有无消息,<br>2.django:<br>    channels: 依赖于redis, twisted<br>    dwebsocket:<br>3.在celery的tasks.py之中，当后端完成数据库读写后，往当前request所在的群组之中发送消息，随后channels会调用chat_message函数，通过self.send()方法将消息发送给前端</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>web面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>常用密码</title>
    <url>/article/b68a8f57.html</url>
    <content><![CDATA[<p>1,<br>steam账户Python_Enthusiasts<br>密码Fy19961009</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫面试题</title>
    <url>/article/70982e52.html</url>
    <content><![CDATA[<p>1,xpath关键字position和contian的区别</p>
<p>psotiton:通过标签的具体所有位置获取标签内容</p>
<p>contian:获取某个属性含有某个字段的标签.</p>
<p>2, scrapy框架各模块的作用</p>
<p>item.py,明确需要提取的数据<br>spiders&#x2F;xxxx.py ,编写爬虫文件,处理请求和响应,以及提取数据(yield item )<br>pipelines.py , 编写管道文件,处理spider返回item,比如本地持久化存储等…<br>settings,py,启动管道组件,ITEM_PIPELINES 以及其他相关设置</p>
<p>3, python处理js反爬过程主要是在headers请求头中添加对网页中的cookie字段进行处理的数据信息.</p>
<p>4,高并发爬虫</p>
<p>高并发爬虫主要通过asynci进行异步处理操作以及通过aiohttp模块对多个url请求进行处理</p>
<p>5,如何将爬取的数据保存到本地或者数据库当中</p>
<p>管道文件中一个管道类对应的是将数据存储到一种平台,爬虫文件提交的item只会给管道文件中第一个被执行的管道类接受,process_item中的return表示将item传递给下一个即将被执行的管道类</p>
<p>6,反爬机制主要包含对多个ip进行反爬处理,防止ip被封,多个ua请求头以及对登录时的验证码进行破解已实现登录功能,</p>
<p>破解验证码可以通过①ddddocr模块.②pytesseract模块,③通过冰拓第三方网站的API进行验证码的识别并破解,实现模拟登录,④先将验证码进行二值化以及灰度化处理,然后通过百度api模块对验证码进行识别处理.</p>
<p>7,分布式爬虫(提升爬取数据的效率)</p>
<p>1, 安装scrapy_redis组件,给原生的scrapy框架提供可以被共享的管道以及调度器,</p>
<p>2, 修改爬虫文件,添加一个新的属性,可以被共享的调度器队列名称,编写数据解析相关操作,</p>
<p>3, 将当前爬虫类的父类修改成RedisCrawSpider</p>
<p>3, 修改配置文件,指定使用可以被共享的管道,指定调度器以及redis服务,</p>
<p>4, 配置redis</p>
<p>8,增量式爬虫: 监测网站数据更新情况,只会爬取网站最新更新出来的数据</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>爬虫面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>项目整理.md</title>
    <url>/article/6f70a492.html</url>
    <content><![CDATA[<p>1，文本转语音采用 ffmeg 工具进行转换。websocket</p>
<p>​     通过pydub包模块实现文本转语音.         http 请求</p>
<p>2，语音转文本：采用vosk模型进行语音识别，将识别结果通过 websocket 的方式返回给前端                                    websocket</p>
<p>​                             采用vosk模型进行语音识别，将识别结果通过http 请求的方式将结果返回给前端                               http 请求                                                                                                                                                                                                </p>
<p>3, 知识图谱，读取不同 excel 表格的文件内容，然后建立对应的节点与关系。建立完成之后通过检查数据判断是否正常写入。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>项目内容整理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安装</title>
    <url>/article/f025fac7.html</url>
    <content><![CDATA[<p>Java环境变量配置:<br>1,<br>JAVA_HOME      F:\Java\jdk-10.0.2<br>2,<br>CLASSPATH        .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;<br>3,<br>%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>编码习惯整理</title>
    <url>/article/e541c025.html</url>
    <content><![CDATA[<ol>
<li><p>修改完代码,记得自测一下(再小的修改也最好自测一下)</p>
</li>
<li><p>方法入参最好都检验</p>
</li>
<li><p>修改老接口时,思考接口的兼容性</p>
</li>
<li><p>对于复杂的代码逻辑,添加清楚的注释</p>
</li>
<li><p>使用完IO资源流,需要关闭</p>
</li>
<li><p>代码采取措施避免运行错误(如数组边界溢出)</p>
</li>
<li><p>尽量不要在循环里远程调用或者对数据库操作,优先考虑批量进行</p>
</li>
<li><p>写完代码,脑洞一下多线程执行会怎样,注意并发一致性问题,</p>
</li>
<li><p>获取对象的属性,先判断对象是否为空</p>
</li>
<li><p>多线程异步优先考虑恰当的线程池,而不是new thread(降低资源损耗,题号响应速度,便于重复利用)&lt;注意线程池隔离&gt;</p>
</li>
<li><p>手动写完代码业务的SQL,先拿去数据库跑一下,同时也explain看下执行计划</p>
</li>
<li><p>调用第三方接口,需要考虑异常处理.安全性,超时重试这几个点(重点的需要考虑签名,加密)</p>
</li>
<li><p>接口考虑幂等性</p>
</li>
<li><p>多线程情况下,考虑线程安全问题</p>
</li>
<li><p>主从延迟问题考虑</p>
</li>
<li><p>缓存的时候,考虑缓存跟DB的一致性,还有(缓存穿透,缓存雪崩和缓存击穿)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编码习惯</category>
      </categories>
      <tags>
        <tag>编码习惯</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析</title>
    <url>/article/d1c27656.html</url>
    <content><![CDATA[<p>numpy模块<br>1,数组的创建语法:<br>一维数组:</p>
<p>&#x2F; : 表示或者</p>
<p>arr &#x3D; np.array(列表&#x2F;range(5))</p>
<p>二维数组:<br>arr2 &#x3D; np.array([[1,2,3,4],[5,6,7,8]])</p>
<p>2,shape:一个表示各维度大小的数组组arr2的维度:arr2.shape<br>,查看各数组的结构(几行几列)  </p>
<p>3,dtype:一个用于说明数组数据类型的对象<br>arr2的数组类型:arr2.dtype<br>4,10代表一维数组的元素个数:arr_zeros &#x3D; np.zeros(10)</p>
<p>5, 3,一维数组的个数,6,每个数组的元素个数:arr_ones &#x3D; np.ones((3,6))</p>
<p>6, 2代表三维度值在数组中的个数,3代表二维度值在数组中的个数,2代表一维度值在数据中的个数 :<br>arr_empty &#x3D; np.empty([2,4])</p>
<p>7, np.arange(5) :构建一维数组[0,1,2,3,4]                     —&gt;序列数组<br>   np.array([[6,7,8,9],np.arange(4)]) :构建二维数组[[6,7,8,9][0,1,2,3,4]]</p>
<p>8,(matrix)矩阵的创建(一般表示二维数组)<br>np.matrix(np.arange(5))  np.maxtrix([[6,7,8,9],np.arange(4)])   </p>
<p>arange返回的是ndarray,<br>range返回的是列表<br>np.arange(8).reshape(4,2):生成4行2列的二维数组</p>
<p>ndarray数据类型可一致可不一致:如果其中包含dtype,数据类型必须一致</p>
<p>9,arr &#x3D; np.array([1,2,3],dtype &#x3D; np.int32)<br>[含dtype数据类型必须一致,不指定默认int64]<br> arr.dtype</p>
<p>10,arr &#x3D; np.array([1.1,2.7,3.5],dtype &#x3D; np.int64)<br>   arr &#x3D; [1,2,3]  将arr数组中的每一个元素类型由 float64 浮点型 转换成 int64 整型数据， 因此小数部分被截取只保留整数部分。</p>
<p>11,ndarray数据类型的转换<br>arr &#x3D; np.array(range(5),dtype &#x3D; np.int64)<br>arr_float &#x3D; arr.astype(np.float64)<br>#整数转小数,若小数转整数会被截取,若有字符数字,也可以转为数值类型</p>
<p>12,将数组的类型转换成另一个数组的类型<br>arr_int &#x3D; np.arange(5)<br>#int转换为float<br>arr &#x3D; arr_int.astype(np.float64)<br> #一维数组<br>arr_float &#x3D; np.array([[1.1,2.7], [5.7,6.3]])<br>#浮点型二维数组<br>将arr_float数组类型转换成arr_int数组类型<br>arr_temp&#x3D;arr_float.astype(arr_int.dtype)转化后小数部分被截取</p>
<p>13,创建二维数组矩阵arr(浮点类型)  —35<br>arr &#x3D; np.array([np.arange(1,5), np.arange(6,10)], dtype&#x3D;np.float64)</p>
<p>矩阵自乘,二维数组中的每个元素都乘以自身得到一个新的结果</p>
<p>arr1 &#x3D; arr * arr </p>
<p>矩阵自乘,二维数组中的每个元素都减去自身得到一个新的结果</p>
<p>arr2 &#x3D; arr - arr</p>
<p>与标量相除,一个标量数字除以二维数组中的每个元素得到一个新的结果</p>
<p>arr3 &#x3D; 1 &#x2F; arr</p>
<p>矩阵1&#x2F;2次幂运算,二维数组中的每个元素计算自身1&#x2F;2 次幂得到一个新的结果</p>
<p>arr4 &#x3D; arr ** 0.5 </p>
<p>14,数组复制<br>b &#x3D; a.view():共用同一个值,<br>b改变,a也跟着改变<br>c &#x3D; a. copy():值不会随着c的值改变而改变</p>
<p>15,np.title(a.(m,n)):扩展<br>将数组扩展为m行n列<br>np.sin(数组):取正弦<br>np.arange(2):2个元素&#x2F;几到几&#x2F;几到几,步长<br>reshape(矩阵,行,列):改变矩阵形状(行列)</p>
<p>16,矩阵.argmax(axis &#x3D; 0):列中最大值索引<br>数组.index(对象):求索引<br>np.sort(matrix,axis&#x3D;1):横向排序:<br>np.argsort(a):最小值索引</p>
<p>17,一般情况下,float和int默认64</p>
<p>18,根据索引查值<br>arr &#x3D; np.arange(10)<br>arr[5]:下标(索引)为5的元素<br>二维数组索引:<br>二维数组对象[二维数组下标索引值,一维数组下标索引值]<br>三维:数组对象[三维度轴索引值,二维度下标索引值,一维度元素下标索引值]<br>所得值为二维数组<br>19,names&#x3D;np.array([‘cnm’,’Bob’,’Jane’,’Bob’])<br>data &#x3D; np.random.randn(4,3):生成正态分布的一些随机数据的二维数组<br>4:根据第一行数组的个数决定<br>print(data[names &#x3D;&#x3D; ‘Bob’,1:]):取Bob所在行的所有数据<br>—&gt;|或   &amp;与  and     or </p>
<p>20,及时创建副本</p>
<p>21,花式索引:针对二维数组:<br>print([[行数1,行数2]]):取具体某行</p>
<p>22,np.ix_:可以将两个一维数组转换成一个用于选取正方形区域的索引器</p>
<p>23,arr.T:可以将一个4行3列的二维数组转换成一个3行4列的二维数组</p>
<p>24,arr&#x3D;np.arange(24).reshape(2,3,4)<br>(2轴3行4列)<br>arr.transpose(1,0,2)<br>(3轴2行4列)</p>
<p>25,arr.swapaxex(1,2):实现三维数组轴对换<br>相当用于将原三维数组以轴z为轴心,向左推90°</p>
<p>26,针对二维数组<br>arr.tofile(‘a.bin’):写入数据<br>print(a.dtype)<br>b &#x3D; np.fromfile(‘a.bin’,dtype &#x3D; a的数据类型):读取数据</p>
<p>27,np.save(‘a.npy’,a):保存数据<br>np.load(‘a.npy’):读取数据</p>
<p>28,保存数据到一个文件中<br>np.savez(‘res.npz’,a,b,c):文件名及数组名<br>np.load(‘res.npz’):读取文件</p>
<p>29,savetext和loadtext可读写一维数组,二维数组,csv文件<br>np.savetext(‘a.txt’,a,fmt&#x3D;’%d’,delimiter&#x3D;’,’):保存为整数,以逗号隔开<br>np.loadtext(‘a.txt’,delimiter&#x3D;’,’):读取时以,隔开</p>
<p>30,np.sqrt(arr):计算各元素的平方根<br>np.exp(arr):计算常量值e各元素值</p>
<p>31,np.maximum(arr1,arr2):对比数组中各元组的大小取大的组成最终数组<br>arr &#x3D; np.random.randn(4)*5<br>np.modf(arr):取数列中的小数部分和整数部分</p>
<p>32,以每个元素为一行,生成N*N的方形二维矩阵<br>xs,xy &#x3D; np.meshgrid(arr,arr)<br>根号下x²+y² :np.sqrt(np.square(xs)) + np.sqrt(np.square(xy))</p>
<p>33,np.where(布尔型,arr1,arr2):<br>当布尔型为True时,arr1,否则arr2</p>
<p>34,arr.sum(axis &#x3D; 0):沿轴0(x轴)求和计算<br>arr.mean(axis &#x3D; 1):沿y轴求平均值<br>arr.std()求标准差</p>
<p>35,arr.sort():默认从小到大排序<br>arr.sort(axis&#x3D;1):每行排序<br>np.unique(arr):去重排序<br>np.inId(arr,[’元素1’,’元素2’]):判断True或False</p>
<p>36,arr1.dot(arr2):矩阵1*矩阵2<br>np.dot(arr1,np.ones(3)):二维矩阵与一维矩阵点积运算后得到一个一维数组</p>
<p>inv(arr):获取矩阵逆运算<br>值<br>qr(arr):获取矩阵的qr操作值分解</p>
<p>37,arr.cumsum(0):所有元素累计和<br>arr.cumprod(0):所有元素累计积</p>
<p>38,axis &#x3D; 1行,0列,z轴</p>
<p>39,标准正态(高斯)分布的4*4数组,arr &#x3D; np.random(size&#x3D;(4,4))<br>40,argmax求临界值</p>
<p>Pandas模块<br>Series,DataFrame<br>Series:<br>obj &#x3D; series([1,3,2,13]):索引在左,内容在右<br>obj.index:求索引<br>obj.values:求值<br>指定索引:<br>obj&#x3D;([1,3,2,7],index&#x3D;[‘a1’,’a3’,’a13’,’a2’])<br>obj[‘a3’]:取值<br>obj[‘a13’]&#x3D;13:改值<br>输出指定范围的索引:obj[[‘a1’,’a13’]]<br>np.exp(obj):e的obj各values值次方<br> a1 in obj:判断索引值是否在obj中<br>dict1 &#x3D; {‘a’:3,’b’:13}<br>#构建series对象<br>obj &#x3D; Series(dict1)<br>new_index &#x3D; [‘w,’’y’]<br>obj2 &#x3D; Series(dict1,new_index)<br>pd.isnull&#x2F;notnull(obj2)::判断是否为空<br>两个series相加:索引并集:values为NaN,</p>
<p>41,将具有等长的多个列表存入DataFrame,自动发添加索引,列名key值自动排序<br>fram&#x3D;DataFrame(dict1,columns&#x3D;[‘w’,’j’,’y’],index&#x3D;[1,3,13]):columns列顺序排列,index:索引顺序排列<br>fram[‘j’]:求某列<br>fram[‘w’]&#x3D;7:赋值操作<br>Series给DataFrame赋值:精确匹配DataFrame索引<br>字典嵌套,外层key作为列,内层key作为索引处理<br>reindex:新索引<br>Method&#x3D;’ffill’&#x2F;’bfill’:实现前向&#x2F;前后插值处理,<br>ix的标签索引实现行列重置<br>Pandas进阶:s表示Series对象,<br>d表示DataFrame对象<br>s.drop(‘索引名’)<br>d.drop([‘索引1’,’索引2’],axis&#x3D;0):删除索引1和3的一栏</p>
<p>add, sub减,mul乘,div除</p>
<p>d1.add(d2,fill_value&#x3D;0):缺失用0代替,相加</p>
<p>排序:s.sort_index(ascending&#x3D;True):升序,false降序</p>
<p>d.sort_values(by&#x3D;’b’,&#x2F;[‘a’,’b’]):按照列值或多个列值排序</p>
<p>操作文件csv&#x2F;txt<br>读取:<br>os:csvPath &#x3D; os.getcwd() + ‘文件存储路径’<br>data &#x3D; pd.read_csv(csvPath + os.sep + ‘tips.csv’):读取数据</p>
<p>写入:data.to_csv(csvPath &#x3D; os.sep + ‘out.csv’)</p>
<p>json操作:<br>设置路径:jsonPath &#x3D; os.getcwd + ‘路径’<br>读取:with open(jsonPath + os.sep +’文件名’ , ‘r’,encoding &#x3D; ‘utf8’) as fp:<br>dump()写入json数据<br>data &#x3D; json.load(fp):读取<br>Df &#x3D; DataFrame(data):将json转换为DataFrame对象</p>
<p>Excel:地址同上<br>xls_file &#x3D; pa.ExcelFile(ExcelPath + os.sep + ‘文件名’)<br>读取有效sheet页<br>table &#x3D; xls_file.prase(‘文件名无后缀,其他都有’)</p>
<p>读取数据库:<br>import pymysql<br>#获取有效的数据库连接引用对象<br>connection &#x3D; pymysql.connect(host &#x3D;’localhost’,post&#x3D;3306,user&#x3D;’root’,password&#x3D;’1’,db&#x3D;’houserentals’,charser&#x3D;’utf8’)<br>#设置查询语句<br>sql &#x3D; ‘select *from emp e where e.lessor &#x3D; 13 ’<br>#使用read_sql函数 检索并转换DataFrame对象<br>df &#x3D; pd.read_sql(sql,connection)<br>#关闭数据库<br>conncetion.close()<br>#测试输出<br>print(df)</p>
<p>42, pandas模块</p>
<p>#显示完整的列</p>
<p>pd.set_option(‘display.max_columns’, None) </p>
<p>#显示完整的行</p>
<p>pd.set_option(‘display.max_rows’, None)</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
</search>
